
def debug_put(str) {
    i = 0
    while i < length(str) {
        putchar(str[i])
        i = i + 1
    }
}

def debug_puts(str) {
    debug_put(str)
    putchar(10)
}

def debug_putn_gte0(n) {
    if n >= 10 {
        lowest = n % 10
        debug_putn_gte0((n - lowest) / 10)
        putchar(lowest + 48)
    } else {
        putchar(n % 10 + 48)
    }
}

def debug_putn(n) {
    if n < 0 {
        puts("-")
        debug_putn_gte0(0 - n)
    } else {
        debug_putn_gte0(n)
    }
}

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return true
        }
    }
    return false
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return true
    } else {
        return false
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return true
    }
    if char_between(chr, "AZ") {
        return true
    }
    return false
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return true
    }
    if chr == "_"[0] {
        return true
    }
    return false
}

def char_id(chr) {
    if char_id0(chr) {
        return true
    }
    if char_isdigit(chr) {
        return true
    }
    return false
}

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def str_to_array(src) {
    ret = []
    i = 0
    while i < length(src) {
        ret = ret ~ [src[i]]
        i = i + 1
    }
    return ret
}

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] >= length(src[0]) {
        return 0
    } else {
        return src[0][src[1]]
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {
        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return false
        }
        i = i + 1
    }
    return true
}

def tokenize_stream1(bsrc) {
    keywords = ["while", "if", "else", "def", "return", "exit", "true", "false", "none"]
    ops_flat = ["<=", ">=", "==", "!=", "=", "~", "+", "-", "%", "*", "/", "<", ">"]
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return ["op", op]
        }
        xop = xop + 1
    }
    first = stream_peek(bsrc)
    if first == " "[0] {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == "("[0] {
        return ["open", stream_read()]
    }
    if first == ")"[0] {
        return ["close", stream_read()]
    }
    if first == "{"[0] {
        return ["open", stream_read()]
    }
    if first == "}"[0] {
        return ["close", stream_read()]
    }
    if first == "["[0] {
        return ["open", stream_read()]
    }
    if first == "]"[0] {
        return ["close", stream_read()]
    }
    if first == ","[0] {
        return ["comma", stream_read()]
    }
    if first == "\n"[0] {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                debug_puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return ["str", ret]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == "n"[0] {
                    ret = ret ~ ["\n"[0]]
                } 
                if cur == "\""[0] {
                    ret = ret ~ ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret = ret ~ ["\\"[0]]
                }
            } else {
                ret = ret ~ [cur]
            }
        }
        debug_puts("bad char")
        exit
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - "0"[0]
        }
        return ["num", n]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc = xsrc ~ [stream_read(bsrc)]
            } else {
                ki = 0
                while ki < length(keywords) {
                    if str_to_array(keywords[ki]) == xsrc {
                        return [keywords[ki], xsrc]
                    }
                    ki = ki + 1
                }
                return ["ident", xsrc]
            }
        }
    }
    if first == 0 {
        return 0
    }
    debug_puts(str_to_array("bad char: ") ~ [first])
    exit
}

def tokenize(src) {
    ssrc = stream_new(src) 
    tokens = []
    while true {
        if stream_peek(ssrc) == 0 {
            return tokens
        }
        token = tokenize_stream1(ssrc)
        tokens = tokens ~ [token]
    }
}

def read_post(tokens, last) {
    first = stream_peek(tokens)
    if first == 0 {
        return last
    }
    if first[0] == "open" {
        if first[1] == "["[0] {
            stream_skip1(tokens)
            index = read_expr_base(tokens)
            stream_skip1(tokens)
            return read_post(tokens, ["index", last, index])
        }
        if first[1] == "("[0] {
            stream_skip1(tokens)
            args = ["call", last]
            if last[0] == "putchar" {
                args = ["putchar"]
            }
            if last[0] == "exec" {
                args = ["exec"]
            }
            if last[0] == "length" {
                args = ["length"]
            }
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    debug_puts("error 1")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return read_post(tokens, args)
                }
                arg = read_expr_base(tokens)
                if arg != none {
                    args = args ~ [arg]
                }
                if cur[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
    }
    return last
}

def read_single(tokens) {
    first = stream_peek(tokens)
    if first == 0 {
        return none
    }
    if first[0] == "true" {
        stream_skip1(tokens)
        return ["bool", true]
    }
    if first[0] == "false" {
        stream_skip1(tokens)
        return ["bool", false]
    }
    if first[0] == "none" {
        stream_skip1(tokens)
        return ["none"]
    }
    if first[0] == "num" {
        stream_skip1(tokens)
        return ["num", first[1]]
    }
    if first[0] == "str" {
        stream_skip1(tokens)
        return ["str", first[1]]
    }
    if first[0] == "ident" {
        stream_skip1(tokens)
        if first[1] == str_to_array("exec") {
            return ["exec"]
        } 
        if first[1] == str_to_array("putchar") {
            return ["putchar"]
        } 
        if first[1] == str_to_array("length") {
            return ["length"]
        } 
        return ["ident", first[1]]
    }
    if first[0] == "open" {
        if first[1] == "["[0] {
            stream_skip1(tokens)
            args = ["array"]
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    debug_puts("error 2")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return args
                }
                expr = read_expr_base(tokens)
                if expr != none {
                    args = args ~ [expr]
                }
                if cur[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
        if first[1] == "("[0] {
            stream_skip1(tokens)
            ret = read_expr_base(tokens)
            stream_skip1(tokens)
            return ret
        }
    }
    return none
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if op == some[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def read_expr(tokens, depth) {
    ops = [["="], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"]]
    if depth >= length(ops) {
        return read_post(tokens, read_single(tokens))
    }
    ret = read_expr(tokens, depth + 1)
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] != "op" {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        stream_skip1(tokens)
        ret = [first[1], ret, read_expr(tokens, depth + 1)]
    }
}

def read_expr_base(tokens) {
    ret = read_expr(tokens, 0)
    return ret
}

def read_stmt(tokens) {
    first = stream_peek(tokens)
    if first[0] == "while" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block = read_block(tokens)
        return ["while", expr, block]
    }
    if first[0] == "def" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block = read_block(tokens)
        return ["def", expr, block]
    }
    if first[0] == "return" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        return ["return", expr]
    }
    if first[0] == "exit" {
        stream_skip1(tokens)
        return ["exit"]
    }
    if first[0] == "if" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block1 = read_block(tokens)
        block2 = ["do"]
        if stream_peek(tokens)[0] == "else" {
            stream_skip1(tokens)
            block2 = read_block(tokens)
        }
        return ["if", expr, block1, block2]
    }
    ret = read_expr_base(tokens)
    return ret
}

def read_block_body(tokens) {
    ret = ["do"]
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] == "close" {
            return ret
        }
        stmt = read_stmt(tokens)
        ret = ret ~ [stmt]
    }
}

def read_block(tokens) {
    first = stream_peek(tokens)
    if first == ["open", "{"[0]] {
        stream_skip1(tokens)
        ret = read_block_body(tokens)
        stream_skip1(tokens)
        return ret
    }
    debug_puts("parser: block error")
    exit
}

def parse(tokens) {
    xstream = stream_new(tokens)
    ret = read_block_body(xstream)
    return ret
}

def opcode(name) {
    if name == "exit" { return 0 }
    if name == "store_reg" { return 1 }
    if name == "store_none" { return 2 }
    if name == "store_bool" { return 3 }
    if name == "store_int" { return 4 }
    if name == "store_fun" { return 5 }
    if name == "fun_done" { return 6 }
    if name == "equal" { return 7 }
    if name == "equal_num" { return 8 }
    if name == "not_equal" { return 9 }
    if name == "not_equal_num" { return 10 }
    if name == "less" { return 11 }
    if name == "less_num" { return 12 }
    if name == "greater" { return 13 }
    if name == "greater_num" { return 14 }
    if name == "less_than_equal" { return 15 }
    if name == "less_than_equal_num" { return 16 }
    if name == "greater_than_equal" { return 17 }
    if name == "greater_than_equal_num" { return 18 }
    if name == "jump" { return 19 }
    if name == "branch_false" { return 20 }
    if name == "branch_true" { return 21 }
    if name == "branch_equal" { return 22 }
    if name == "branch_equal_num" { return 23 }
    if name == "branch_not_equal" { return 24 }
    if name == "branch_not_equal_num" { return 25 }
    if name == "branch_less" { return 26 }
    if name == "branch_less_num" { return 27 }
    if name == "branch_greater" { return 28 }
    if name == "branch_greater_num" { return 29 }
    if name == "branch_less_than_equal" { return 30 }
    if name == "branch_less_than_equal_num" { return 31 }
    if name == "branch_greater_than_equal" { return 32 }
    if name == "branch_greater_than_equal_num" { return 33 }
    if name == "inc" { return 34 }
    if name == "inc_num" { return 35 }
    if name == "dec" { return 36 }
    if name == "dec_num" { return 37 }
    if name == "add" { return 38 }
    if name == "add_num" { return 39 }
    if name == "sub" { return 40 }
    if name == "sub_num" { return 41 }
    if name == "mul" { return 42 }
    if name == "mul_num" { return 43 }
    if name == "div" { return 44 }
    if name == "div_num" { return 45 }
    if name == "mod" { return 46 }
    if name == "mod_num" { return 47 }
    if name == "concat" { return 48 }
    if name == "static_call0" { return 49 }
    if name == "static_call1" { return 50 }
    if name == "static_call2" { return 51 }
    if name == "static_call" { return 52 }
    if name == "tail_call0" { return 53 }
    if name == "tail_call1" { return 54 }
    if name == "tail_call2" { return 55 }
    if name == "tail_call" { return 56 }
    if name == "call0" { return 57 }
    if name == "call1" { return 58 }
    if name == "call2" { return 59 }
    if name == "call" { return 60 }
    if name == "return" { return 61 }
    if name == "putchar" { return 62 }
    if name == "ref_new" { return 63 }
    if name == "box_new" { return 64 }
    if name == "string_new" { return 65 }
    if name == "array_new" { return 66 }
    if name == "map_new" { return 67 }
    if name == "ref_get" { return 68 }
    if name == "box_get" { return 69 }
    if name == "box_set" { return 70 }
    if name == "length" { return 71 }
    if name == "index_get" { return 72 }
    if name == "index_set" { return 73 }
    if name == "type" { return 74 }
    if name == "call_handler" { return 75 }
    if name == "set_handler" { return 76 }
    if name == "return_handler" { return 77 }
    if name == "exit_handler" { return 78 }
    if name == "exec" { return 79 }
    debug_puts(str_to_array("unknown opcode: ") ~ name)
    exit
}

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [opcode("store_int"), ret, form[1]]
    return ret
}

def emit_bool(form, out) {
    ret = reg(out)
    if out[1] {
        out[0] = out[0] ~ [opcode("store_bool"), ret, 1]
    } else {
        out[0] = out[0] ~ [opcode("store_bool"), ret, 0]
    }
    return ret
}

def emit_none(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [opcode("store_none"), ret]
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if res == none {
        debug_puts(str_to_array("compile error: undefined: ") ~ form[1])
        exit
    }
    return res
}

def emit_binop(op, form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    ret = reg(out)
    out[0] = out[0] ~ [op, ret, r1, r2]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] = out[0] ~ [opcode("putchar"), r1]
    return none
}

def emit_exec(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [opcode("exec"), r1, r2]
    return none
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [opcode("length"), ret, r1]
    return ret
}

def emit_do(form, out) {
    i = 1
    while i < length(form) {
        emit_to(form[i], out)
        i = i + 1
    } 
    return none
}

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        if vars[i][0] == name {
            return vars[i][1]
        }
        i = i + 1
    }
    return none
}

def emit_set(form, out) {
    found = findvar(out[2], form[1][1])
    if found == none {
        from = emit_to(form[2], out)
        to = reg(out)
        out[2] = out[2] ~ [[form[1][1], to]]
        out[0] = out[0] ~ [opcode("store_reg"), to, from]
        return to
    } else {
        from = emit_to(form[2], out)
        out[0] = out[0] ~ [opcode("store_reg"), found, from]
        return found
    }
}

def emit_def(form, out) {
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    i = 2
    while i < length(call) {
        out[2] = out[2] ~ [[call[i][1], i - 1]]
        i = i + 1
    }
    out[1] = i - 1
    jout = length(out[0]) + 1
    nregs = length(out[0]) + 2
    out[0] = out[0] ~ [opcode("jump"), "jump", 256]
    out[3] = out[3] ~ [[call[1][1], length(out[0])]]
    resreg = emit_to(body, out)
    if resreg == none {
        out[0] = out[0] ~ [opcode("store_none"), 0, opcode("return"), 0]
    } else {
        out[0] = out[0] ~ [opcode("return"), resreg]
    }
    out[0] = out[0] ~ [opcode("fun_done")]
    out[0][nregs] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0][jout] = length(out[0])
    return none
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] = out[0] ~ [opcode("return"), rreg]
    return none
}

def emit_exit(form, out) {
    out[0] = out[0] ~ [opcode("exit")]
    return none
}

def emit_call(form, out) {
    regs = []
    i = 2
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("static_call"), ret, "link", form[1][1], length(regs)] ~ regs
    return ret
}

def emit_while(form, out) {
    jredo = length(out[0])
    cond = emit_to(form[1], out)
    sout = length(out[0]) + 2
    sfall = length(out[0]) + 4
    out[0] = out[0] ~ [opcode("branch_true"), sfall, "jump", cond]
    emit_to(form[2], out)
    out[0] = out[0] ~ [opcode("jump"), jredo]
    out[0][sout] = length(out[0])
    return none
}

def emit_if(form, out) {
    cond = emit_to(form[1], out)
    st = length(out[0]) + 1
    sf = length(out[0]) + 2
    out[0] = out[0] ~ [opcode("branch_true"), "jump", "jump", cond]
    jt = length(out[0])
    emit_to(form[2], out)
    so1 = length(out[0]) + 1
    out[0] = out[0] ~ [opcode("jump"), "jump"]
    jf = length(out[0])
    emit_to(form[3], out)
    so2 = length(out[0]) + 1
    out[0] = out[0] ~ [opcode("jump"), "jump"]
    jout = length(out[0])
    out[0][st] = jt
    out[0][sf] = jf
    out[0][so1] = jout
    out[0][so2] = jout
    return none
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("array_new"), ret, length(regs)] ~ regs
    return ret
}

def emit_str(form, out) {
    chrs = []
    i = 0
    while i < length(form[1]) {
        chrs = chrs ~ [form[1][i]]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("string_new"), ret, length(chrs)] ~ chrs
    return ret
}

def emit_to(form, out) {
    if form[0] == "num" {
        return emit_num(form, out)
    }
    if form[0] == "bool" {
        return emit_bool(form, out)
    }
    if form[0] == "none" {
        return emit_none(form, out)
    }
    if form[0] == "~" {
        return emit_binop(opcode("concat"), form, out)
    }
    if form[0] == "+" {
        return emit_binop(opcode("add"), form, out)
    }
    if form[0] == "-" {
        return emit_binop(opcode("sub"), form, out)
    }
    if form[0] == "*" {
        return emit_binop(opcode("mul"), form, out)
    }
    if form[0] == "/" {
        return emit_binop(opcode("div"), form, out)
    }
    if form[0] == "%" {
        return emit_binop(opcode("mod"), form, out)
    }
    if form[0] == "<" {
        return emit_binop(opcode("less"), form, out)
    }
    if form[0] == ">" {
        return emit_binop(opcode("greater"), form, out)
    }
    if form[0] == "<=" {
        return emit_binop(opcode("less_than_equal"), form, out)
    }
    if form[0] == ">=" {
        return emit_binop(opcode("greater_than_equal"), form, out)
    }
    if form[0] == "==" {
        return emit_binop(opcode("equal"), form, out)
    }
    if form[0] == "!=" {
        return emit_binop(opcode("not_equal"), form, out)
    }
    if form[0] == "index" {
        return emit_binop(opcode("index_get"), form, out)
    }
    if form[0] == "def" {
        return emit_def(form, out)
    }
    if form[0] == "return" {
        return emit_return(form, out)
    }
    if form[0] == "exit" {
        return emit_exit(form, out)
    }
    if form[0] == "call" {
        return emit_call(form, out)
    }
    if form[0] == "ident" {
        return emit_ident(form, out)
    }
    if form[0] == "putchar" {
        return emit_putchar(form, out)
    }
    if form[0] == "exec" {
        return emit_exec(form, out)
    }
    if form[0] == "length" {
        return emit_length(form, out)
    }
    if form[0] == "array" {
        return emit_array(form, out)
    }
    if form[0] == "str" {
        return emit_str(form, out)
    }
    if form[0] == "while" {
        return emit_while(form, out)
    }
    if form[0] == "if" {
        return emit_if(form, out)
    }
    if form[0] == "=" {
        return emit_set(form, out)
    }
    if form[0] == "do" {
        return emit_do(form, out)
    }
    debug_puts("unknwon form: " ~ form[0])
    exit
}

def link(out) {
    ret = []
    i = 0
    while i < length(out[0]) {
        if out[0][i] == "link" {
            i = i + 1
            func = findvar(out[3], out[0][i])
            if func == none {
                debug_puts(str_to_array("link error: undefined: ") ~ out[0][i])
                exit
            }
            ret = ret ~ [func]
        } else {
            ret = ret ~ [out[0][i]]
        }
        i = i + 1
    }
    return ret
}

def emit(form) {
    out = [[], 0, [[str_to_array("args"), 0]], []]
    emit_to(form, out)
    out[0] = out[0] ~ [opcode("exit")]
    linked = link(out)
    return linked
}

def main(srcs) {
    if length(srcs) >= 1 {
        rest = []
        i = 1
        while i < length(srcs) {
            rest = rest ~ [srcs[i]]
            i = i + 1
        }
        tokens = tokenize(srcs[0])
        ast = parse(tokens)
        bc = emit(ast)
        i = 0
        while i < length(bc) {
            debug_putn(i)
            debug_puts("\n")
        }
        exec(bc, rest)
    } else {
        debug_puts(str_to_array("too few args: ") ~ [48 + length(srcs)] )
    }
}

main(args)
