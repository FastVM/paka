### char utils

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return true
        }
    }
    return false
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return true
    } else {
        return false
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return true
    }
    if char_between(chr, "AZ") {
        return true
    }
    return false
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return true
    }
    if chr == "_"[0] {
        return true
    }
    return false
}

def char_id(chr) {
    if char_id0(chr) {
        return true
    }
    if char_isdigit(chr) {
        return true
    }
    return false
}

### string utils

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def str_to_array(src) {
    ret = []
    i = 0
    while i < length(src) {
        ret = ret ~ [src[i]]
        i = i + 1
    }
    return ret
}

### char stream utils

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] >= length(src[0]) {
        return 0
    } else {
        return src[0][src[1]]
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {
        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return false
        }
        i = i + 1
    }
    return true
}

### tokenizer

def tokenize_stream1(bsrc) {
    keywords = ["while", "if", "else"]
    ops_flat = ["<=", ">=", "==", "!=", "=", "+", "-", "%", "*", "/", "<", ">"]
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return ["op", op]
        }
        xop = xop + 1
    }
    first = stream_peek(bsrc)
    if first == " "[0] {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == "("[0] {
        return ["open", stream_read()]
    }
    if first == ")"[0] {
        return ["close", stream_read()]
    }
    if first == "{"[0] {
        return ["open", stream_read()]
    }
    if first == "}"[0] {
        return ["close", stream_read()]
    }
    if first == "["[0] {
        return ["open", stream_read()]
    }
    if first == "]"[0] {
        return ["close", stream_read()]
    }
    if first == ","[0] {
        return ["comma", stream_read()]
    }
    if first == "\n"[0] {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                println("eof in str")
                exit
            }
            if cur == "\""[0] {
                return ["str", ret]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == "n"[0] {
                    ret = ret ~ ["\n"[0]]
                } 
                if cur == "\""[0] {
                    ret = ret ~ ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret = ret ~ ["\\"[0]]
                }
            } else {
                ret = ret ~ [cur]
            }
        }
        println("bad char")
        exit
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - "0"[0]
        }
        return ["num", n]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc = xsrc ~ [stream_read(bsrc)]
            } else {
                ki = 0
                while ki < length(keywords) {
                    if str_to_array(keywords[ki]) == xsrc {
                        return [keywords[ki], xsrc]
                    }
                    ki = ki + 1
                }
                return ["ident", xsrc]
            }
        }
    }
    if stream_peek(bsrc) == 0 {
        return 0
    }
    println(["bad char", stream_peek(bsrc)])
    exit
}

def tokenize(src) {
    ssrc = stream_new(src) 
    tokens = []
    while true {
        if stream_peek(ssrc) == 0 {
            return tokens
        }
        token = tokenize_stream1(ssrc)
        tokens = tokens ~ [token]
    }
}

### parser

def read_post(tokens, last) {
    first = stream_peek(tokens)
    if first == 0 {
        return last
    }
    if first[0] == "open" {
        if first[1] == "["[0] {
            stream_skip1(tokens)
            index = read_expr_base(tokens)
            stream_skip1(tokens)
            return ["index", last, index]
        }
        if first[1] == "("[0] {
            stream_skip1(tokens)
            args = ["call", last]
            if last[0] == "putchar" {
                args = ["putchar"]
            }
            if last[0] == "length" {
                args = ["length"]
            }
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    println("error 1")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return args
                }
                args = args ~ [read_expr_base(tokens)]
                if cur[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
    }
    return last
}

def read_single(tokens) {
    first = stream_peek(tokens)
    if first == 0 {
        return none
    }
    if first[0] == "num" {
        stream_skip1(tokens)
        return ["num", first[1]]
    }
    if first[0] == "str" {
        stream_skip1(tokens)
        return ["str", first[1]]
    }
    if first[0] == "ident" {
        stream_skip1(tokens)
        if first[1] == str_to_array("putchar") {
            return ["putchar"]
        } 
        if first[1] == str_to_array("length") {
            return ["length"]
        } 
        return ["ident", first[1]]
    }
    if first[0] == "open" {
        if first[1] == "["[0] {
            stream_skip1(tokens)
            args = ["array"]
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    println("error 2")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return args
                }
                expr = read_expr_base(tokens)
                if expr != none {
                    args = args ~ [expr]
                }
                if cur[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
        if first[1] == "("[0] {
            stream_skip1(tokens)
            ret = read_expr_base(tokens)
            stream_skip1(tokens)
            return ret
        }
    }
    return none
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if op == some[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def read_expr(tokens, depth) {
    ops = [["="], ["<", ">", "<=", ">=", "==", "!="], ["+", "-"], ["%", "*", "/"]]
    if depth >= length(ops) {
        return read_post(tokens, read_single(tokens))
    }
    ret = read_expr(tokens, depth + 1)
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] != "op" {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        stream_skip1(tokens)
        ret = [first[1], ret, read_expr(tokens, depth + 1)]
    }
}

def read_expr_base(tokens) {
    ret = read_expr(tokens, 0)
    return ret
}

def read_stmt(tokens) {
    first = stream_peek(tokens)
    if first[0] == "while" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block = read_block(tokens)
        return ["while", expr, block]
    }
    if first[0] == "if" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block1 = read_block(tokens)
        block2 = ["do"]
        if stream_peek(tokens)[0] == "else" {
            stream_skip1(tokens)
            block2 = read_block(tokens)
        }
        return ["if", expr, block1, block2]
    }
    ret = read_expr_base(tokens)
    return ret
}

def read_block_body(tokens) {
    ret = ["do"]
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] == "close" {
            return ret
        }
        ret = ret ~ [read_stmt(tokens)]
    }
}

def read_block(tokens) {
    first = stream_peek(tokens)
    if first == ["open", "{"[0]] {
        stream_skip1(tokens)
        ret = read_block_body(tokens)
        stream_skip1(tokens)
        return ret
    }
    println("parser: block error")
    exit
}

def parse(tokens) {
    xstream = stream_new(tokens)
    ret = read_block_body(xstream)
    return ret
}

### opcodes walker

op_num = 0
opcode_exit = op_num op_num = op_num + 1
opcode_store_reg = op_num op_num = op_num + 1
opcode_store_none = op_num op_num = op_num + 1
opcode_store_bool = op_num op_num = op_num + 1
opcode_store_int = op_num op_num = op_num + 1
opcode_store_fun = op_num op_num = op_num + 1
opcode_fun_done = op_num op_num = op_num + 1
opcode_equal = op_num op_num = op_num + 1
opcode_equal_num = op_num op_num = op_num + 1
opcode_not_equal = op_num op_num = op_num + 1
opcode_not_equal_num = op_num op_num = op_num + 1
opcode_less = op_num op_num = op_num + 1
opcode_less_num = op_num op_num = op_num + 1
opcode_greater = op_num op_num = op_num + 1
opcode_greater_num = op_num op_num = op_num + 1
opcode_less_than_equal = op_num op_num = op_num + 1
opcode_less_than_equal_num = op_num op_num = op_num + 1
opcode_greater_than_equal = op_num op_num = op_num + 1
opcode_greater_than_equal_num = op_num op_num = op_num + 1
opcode_jump = op_num op_num = op_num + 1
opcode_branch_false = op_num op_num = op_num + 1
opcode_branch_true = op_num op_num = op_num + 1
opcode_branch_equal = op_num op_num = op_num + 1
opcode_branch_equal_num = op_num op_num = op_num + 1
opcode_branch_not_equal = op_num op_num = op_num + 1
opcode_branch_not_equal_num = op_num op_num = op_num + 1
opcode_branch_less = op_num op_num = op_num + 1
opcode_branch_less_num = op_num op_num = op_num + 1
opcode_branch_greater = op_num op_num = op_num + 1
opcode_branch_greater_num = op_num op_num = op_num + 1
opcode_branch_less_than_equal = op_num op_num = op_num + 1
opcode_branch_less_than_equal_num = op_num op_num = op_num + 1
opcode_branch_greater_than_equal = op_num op_num = op_num + 1
opcode_branch_greater_than_equal_num = op_num op_num = op_num + 1
opcode_inc = op_num op_num = op_num + 1
opcode_inc_num = op_num op_num = op_num + 1
opcode_dec = op_num op_num = op_num + 1
opcode_dec_num = op_num op_num = op_num + 1
opcode_add = op_num op_num = op_num + 1
opcode_add_num = op_num op_num = op_num + 1
opcode_sub = op_num op_num = op_num + 1
opcode_sub_num = op_num op_num = op_num + 1
opcode_mul = op_num op_num = op_num + 1
opcode_mul_num = op_num op_num = op_num + 1
opcode_div = op_num op_num = op_num + 1
opcode_div_num = op_num op_num = op_num + 1
opcode_mod = op_num op_num = op_num + 1
opcode_mod_num = op_num op_num = op_num + 1
opcode_concat = op_num op_num = op_num + 1
opcode_static_call0 = op_num op_num = op_num + 1
opcode_static_call1 = op_num op_num = op_num + 1
opcode_static_call2 = op_num op_num = op_num + 1
opcode_static_call = op_num op_num = op_num + 1
opcode_tail_call0 = op_num op_num = op_num + 1
opcode_tail_call1 = op_num op_num = op_num + 1
opcode_tail_call2 = op_num op_num = op_num + 1
opcode_tail_call = op_num op_num = op_num + 1
opcode_call0 = op_num op_num = op_num + 1
opcode_call1 = op_num op_num = op_num + 1
opcode_call2 = op_num op_num = op_num + 1
opcode_call = op_num op_num = op_num + 1
opcode_return = op_num op_num = op_num + 1
opcode_putchar = op_num op_num = op_num + 1
opcode_ref_new = op_num op_num = op_num + 1
opcode_box_new = op_num op_num = op_num + 1
opcode_string_new = op_num op_num = op_num + 1
opcode_array_new = op_num op_num = op_num + 1
opcode_map_new = op_num op_num = op_num + 1
opcode_ref_get = op_num op_num = op_num + 1
opcode_box_get = op_num op_num = op_num + 1
opcode_box_set = op_num op_num = op_num + 1
opcode_length = op_num op_num = op_num + 1
opcode_index_get = op_num op_num = op_num + 1
opcode_index_set = op_num op_num = op_num + 1
opcode_type = op_num op_num = op_num + 1
opcode_call_handler = op_num op_num = op_num + 1
opcode_set_handler = op_num op_num = op_num + 1
opcode_return_handler = op_num op_num = op_num + 1
opcode_exit_handler = op_num op_num = op_num + 1

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [opcode_store_int, ret, form[1]]
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    return res
}

def emit_binop(op, form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    ret = reg(out)
    out[0] = out[0] ~ [op, ret, r1, r2]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] = out[0] ~ [opcode_putchar, r1]
    return none
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [opcode_length, ret, r1]
    return ret
}

def emit_do(form, out) {
    i = 1
    while i < length(form) {
        emit_to(form[i], out)
        i = i + 1
    } 
    return none
}

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        if vars[i][0] == name {
            return vars[i][1]
        }
        i = i + 1
    }
    return none
}

def emit_set(form, out) {
    found = findvar(out[2], form[1][1])
    if found == none {
        from = emit_to(form[2], out)
        to = reg(out)
        out[2] = out[2] ~ [[form[1][1], to]]
        out[0] = out[0] ~ [opcode_store_reg, to, from]
        return to
    } else {
        from = emit_to(form[2], out)
        out[0] = out[0] ~ [opcode_store_reg, found, from]
        return found
    }
}

def emit_while(form, out) {
    jredo = length(out[0])
    cond = emit_to(form[1], out)
    sout = length(out[0]) + 2
    sfall = length(out[0]) + 4
    out[0] = out[0] ~ [opcode_branch_true, sfall, 0, cond]
    emit_to(form[2], out)
    out[0] = out[0] ~ [opcode_jump, jredo]
    out[0][sout] = length(out[0])
    return none
}

def emit_if(form, out) {
    cond = emit_to(form[1], out)
    st = length(out[0]) + 1
    sf = length(out[0]) + 2
    out[0] = out[0] ~ [opcode_branch_true, 0, 0, cond]
    jt = length(out[0])
    emit_to(form[2], out)
    so1 = length(out[0]) + 1
    out[0] = out[0] ~ [opcode_jump, 0]
    jf = length(out[0])
    emit_to(form[3], out)
    so2 = length(out[0]) + 1
    out[0] = out[0] ~ [opcode_jump, 0]
    jout = length(out[0])
    out[0][st] = jt
    out[0][sf] = jf
    out[0][so1] = jout
    out[0][so2] = jout
    return none
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode_array_new, ret, length(regs)] ~ regs
    return ret
}

def emit_str(form, out) {
    chrs = []
    i = 0
    while i < length(form[1]) {
        chrs = chrs ~ [form[1][i]]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode_string_new, ret, length(chrs)] ~ chrs
    return ret
}

def emit_to(form, out) {
    if form[0] == "num" {
        return emit_num(form, out)
    }
    if form[0] == "+" {
        return emit_binop(opcode_add, form, out)
    }
    if form[0] == "-" {
        return emit_binop(opcode_sub, form, out)
    }
    if form[0] == "*" {
        return emit_binop(opcode_mul, form, out)
    }
    if form[0] == "/" {
        return emit_binop(opcode_div, form, out)
    }
    if form[0] == "%" {
        return emit_binop(opcode_mod, form, out)
    }
    if form[0] == "<" {
        return emit_binop(opcode_less, form, out)
    }
    if form[0] == ">" {
        return emit_binop(opcode_greater, form, out)
    }
    if form[0] == "<=" {
        return emit_binop(opcode_less_than_equal, form, out)
    }
    if form[0] == ">=" {
        return emit_binop(opcode_greater_than_equal, form, out)
    }
    if form[0] == "==" {
        return emit_binop(opcode_equal, form, out)
    }
    if form[0] == "!=" {
        return emit_binop(opcode_not_equal, form, out)
    }
    if form[0] == "index" {
        return emit_binop(opcode_index_get, form, out)
    }
    if form[0] == "ident" {
        return emit_ident(form, out)
    }
    if form[0] == "putchar" {
        return emit_putchar(form, out)
    }
    if form[0] == "length" {
        return emit_length(form, out)
    }
    if form[0] == "array" {
        return emit_array(form, out)
    }
    if form[0] == "str" {
        return emit_str(form, out)
    }
    if form[0] == "while" {
        return emit_while(form, out)
    }
    if form[0] == "if" {
        return emit_if(form, out)
    }
    if form[0] == "=" {
        return emit_set(form, out)
    }
    if form[0] == "do" {
        return emit_do(form, out)
    }
}

def emit(form) {
    out = [[], 0, []]
    emit_to(form, out)
    out[0] = out[0] ~ [opcode_exit]
    println(out[0])
    return out[0]
}

exec(emit(parse(tokenize("
    x = \"123\"
    i = 0
    while i < length(x) {
        putchar(x[i])
        i = i + 1
    }
    putchar(10)
"))))