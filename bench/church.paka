# combs
U = f => f(f);
I = x => x;

# boolean
TRUE = x => y => x;
FALSE = x => y => y;
IF = b => t => f => b(t)(f);
bool = l => if (l != 0) {TRUE;} else {FALSE;};
unbool = n => n(1)(0);
AND = a => b => IF(a)(IF(b, TRUE, FALSE))(FALSE);
OR = a => b => IF(a)(TRUE)(IF(b)(TRUE)(FALSE));
NOT = b => b(FALSE)(TRUE);

# natural
nat = n => f => lambda(y) {
    z = y;
    i = 0;
    while (i < n)
    {
        z = f(z);
        i += 1;
    };
    return z;
};
num = n => n(x => x + 1)(0);
SUCC = n => f => z => f(n(f)(z));
PRED = n => f => x => n(g => h => h(g(f)))(u => x)(u => u);
ZERO = f => z => z;
ONE = SUCC(ZERO);
TWO = SUCC(ONE);
ADD = n => m => f => z => n(f)(m(f)(z));
MUL = n => m => f => z => n(m(f))(z);
ISZERO = n => n(u => FALSE)(TRUE);
FACT = a =>
    U(s => n =>
        IF(ISZERO(n))
            (u => ONE)
            (u => MUL(n)(s(s)(PRED(n))(I))))
        (a)(I);
        
io.print(num(FACT(nat(8))));