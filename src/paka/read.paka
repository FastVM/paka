
def paka_skip_comma(tokens) {
    first = token_stream_peek(tokens)
    if first[0] == token.comma {
        token_stream_skip1(tokens)
    }
}

def paka_read_scall(tokens, nargs, args, state) {
    target = nargs + length(args)
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error eof arg")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                if length(args) != target {
                    puts("error: argc")
                    exit
                }
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = args ~ [arg]
            paka_skip_comma(tokens)
        }
    }
    while length(args) < target {
        cur = token_stream_peek(tokens)
        if length(cur) == 0 {
            puts("error eof arg")
        }
        arg = paka_read_expr_base(tokens, state)
        args = args ~ [arg]
        paka_skip_comma(tokens)
    }
    return paka_read_post(tokens, args, state)
}

def paka_read_call(tokens, args, state) {
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error 1")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = args ~ [arg]
            paka_skip_comma(tokens)
        }
    }
    puts("error: wanted `(`")
    exit
}

def paka_read_post(tokens, last, state) {
    first = token_stream_peek(tokens)
    if length(first) == 0 {
        return last
    }
    if first[0] == token.open.square {
        token_stream_skip1(tokens)
        index = paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return paka_read_post(tokens, [vm.ast.index, last, index], state)
    }
    if first[0] == token.open.paren {
        if last[0] != vm.ast.ident {
            put("cannot call anything but idents: ")
            putn(last[0])
            putchar(10)
            exit
        }
        name = last[1]
        found = findvar(state[1], name)
        if length(found) == 0 {
            args = [vm.ast.call, last] 
            return paka_read_call(tokens, args, state)
        } else {
            args = [vm.ast.call, last] 
            return paka_read_scall(tokens, found[0], args, state)
        }
    }
    if last[0] == vm.ast.ident {
        name = last[1]
        found = findvar(state[1], name)
        if length(found) == 1 {
            args = [vm.ast.call, last] 
            return paka_read_scall(tokens, found[0], args, state)
        }
    }
    return last
}

def paka_read_single(tokens, state) {
    first = token_stream_peek(tokens)
    if length(first) == 0 {
        return 0
    }
    if first[0] == token.open.square {
        token_stream_skip1(tokens)
        args = [vm.ast.static_array]
        while 1 {
            cur = token_stream_peek(tokens)
            if cur[0] == token.close.square {
                token_stream_skip1(tokens)
                return args
            }
            expr = paka_read_expr_base(tokens, state)
            args = args ~ [expr]
            paka_skip_comma(tokens)
        } 
    }
    if first[0] == token.open.paren {
        token_stream_skip1(tokens)
        ret = paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    if first[0] == token.num {
        token_stream_skip1(tokens)
        return [vm.ast.num, first[1]]
    }
    if first[0] == token.str {
        token_stream_skip1(tokens)
        return [vm.ast.str, first[1]]
    }
    if first[0] == token.ident {
        token_stream_skip1(tokens)
        if str.eq(first[1], "putchar") {
            return paka_read_scall(tokens, 1, [vm.ast.putchar], state)
        } 
        if str.eq(first[1], "length") {
            return paka_read_scall(tokens, 1, [vm.ast.length], state)
        }
        if str.eq(first[1], "dump") {
            return paka_read_scall(tokens, 2, [vm.ast.dump], state)
        }
        if str.eq(first[1], "write") {
            return paka_read_scall(tokens, 2, [vm.ast.write], state)
        }
        if str.eq(first[1], "read") {
            return paka_read_scall(tokens, 1, [vm.ast.read], state)
        }
        if str.eq(first[1], "import") {
            return paka_read_scall(tokens, 1, [vm.ast.import], state)
        }
        return [vm.ast.ident, first[1]]
    }
    if first[0] == token.keyword.if {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block1 = paka_read_block(tokens, state)
        block2 = [vm.ast.do]
        first = token_stream_peek(tokens)
        if first[0] == token.keyword.else {
            token_stream_skip1(tokens)
            block2 = paka_read_block(tokens, state)
        }
        return [vm.ast.if, expr, block1, block2]
    }
    put("error: unexpected token#")
    putn(first[0])
    puts(".")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if str.eq(op, some[i]) {
            return 0
        }
        i = i + 1
    }
    return 1
}

def paka_read_expr(tokens, depth, state) {
    ops = state[0]
    if depth >= length(ops) {
        return paka_read_post(tokens, paka_read_single(tokens, state), state)
    }
    ret = paka_read_expr(tokens, depth + 1, state)
    while 1 {
        first = token_stream_peek(tokens)
        if length(first) == 0 {
            return ret
        }
        if first[0] != token.op {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        token_stream_skip1(tokens)
        ret = [vm.ast.op, first[1], ret, paka_read_expr(tokens, depth + 1, state)]
    }
}

def paka_read_expr_base(tokens, state) {
    ret = paka_read_expr(tokens, 0, state)
    return ret
}

def paka_read_stmt(tokens, state) {
    first = token_stream_peek(tokens)
    if first[0] == token.keyword.while {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.while, expr, block]
    }
    if first[0] == token.keyword.def {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.def, expr, block]
    }
    if first[0] == token.keyword.return {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        return [vm.ast.return, expr]
    }
    if first[0] == token.keyword.defer {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        return [vm.ast.defer, expr]
    }
    if first[0] == token.keyword.macro {
        token_stream_skip1(tokens)
        name = token_stream_read(tokens)
        first = token_stream_peek(tokens)
        block = paka_read_block(tokens, state)
        return [vm.ast.enum, [vm.ast.ident, name[1]], block]
    }
    if first[0] == token.keyword.exit {
        token_stream_skip1(tokens)
        return [vm.ast.exit]
    }
    ret = paka_read_expr_base(tokens, state)
    return ret
}

def paka_read_block_body(tokens, state) {
    ret = [vm.ast.do]
    while 1 {
        first = token_stream_peek(tokens)
        if length(first) == 0 {
            return ret
        }
        if first[0] == token.close.curly {
            return ret
        }
        stmt = paka_read_stmt(tokens, state)
        ret = ret ~ [stmt]
    }
}

def paka_read_block(tokens, state) {
    first = token_stream_peek(tokens)
    if first[0] == token.open.curly {
        token_stream_skip1(tokens)
        ret = paka_read_block_body(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    return [vm.ast.do, paka_read_stmt(tokens, state)]
}

def paka_read_nargs(tokens, name, state) {
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error: need `)` after args to def")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                return n
            }
            paka_read_expr_base(tokens, state)
            n = n + 1
            paka_skip_comma(tokens)
        }
    } else {
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error: need `:` after def")
            }
            if cur[0] == token.op {
                if str.eq(cur[1], ":") {
                    token_stream_skip1(tokens)
                    return n
                }
            }
            paka_read_expr_base(tokens, state)
            n = n + 1
            paka_skip_comma(tokens)
        }
    }
}

def paka_build_defs(tokens, state) {
    ret = []
    while 1 {
        first = token_stream_read(tokens)
        if first[0] == token.keyword.def {
            name = token_stream_read(tokens)
            argc = paka_read_nargs(tokens, name[1], state)
            ret = ret ~ [name[1], argc]
        }
        if length(first) == 0 {
            return ret
        }
    }
}

def paka_parse(src) {
    ops = [["="], [":"], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"], ["@"]]
    state = [ops, []]
    state = [ops, paka_build_defs(token_stream_new(src), state)]
    ret = paka_read_block_body(token_stream_new(src), state)
    return ret
}