
def paka_tokenize_stream1(bsrc, ops_flat) {
    first = stream_peek(bsrc)
    if first == ' ' {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if first == 10 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if first == '#' {
        stream_skip1(bsrc)
        while true {
            cur = stream_read(bsrc)
            if cur == 10 {
                return paka_tokenize_stream1(bsrc, ops_flat)
            }
        }
    }
    if first == '(' {
        stream_skip1()
        return token.open.paren
    }
    if first == ')' {
        stream_skip1()
        return token.close.paren
    }
    if first == '{' {
        stream_skip1()
        return token.open.curly
    }
    if first == '}' {
        stream_skip1()
        return token.close.curly
    }
    if first == '[' {
        stream_skip1()
        return token.open.square
    }
    if first == ']' {
        stream_skip1()
        return token.close.square
    }
    if first == ',' {
        stream_skip1()
        return token.comma
    }
    if first == ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if cur == "\\"[0] {
            cur = stream_read(bsrc)
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            if cur == 'n' {
                return [token.num, 10]
            } 
            if cur == "\""[0] {
                return [token.num, cur]
            }
            if cur == "\\"[0] {
                return [token.num, cur]
            }
        } else {
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            return [token.num, cur]
        }
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return [token.str, ret]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == 'n' {
                    ret ~= [10]
                } 
                if cur == "\""[0] {
                    ret ~= ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret ~= ["\\"[0]]
                }
            } else {
                ret ~= [cur]
            }
        }
        puts("bad char")
        exit
    }
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return [token.op, op]
        }
        xop = xop + 1
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - '0'
        }
        return [token.num, n]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc ~= [stream_read(bsrc)]
            } else {
                n0 = xsrc[0]
                if n0 == 'w' {
                    if xsrc == "while" {
                        return token.keyword.while
                    }
                    if xsrc == "when" {
                        return token.keyword.when
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'i' {
                    if xsrc == "if" {
                        return token.keyword.if
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'e' {
                    if xsrc == "else" {
                        return token.keyword.else
                    }
                    if xsrc == "exit" {
                        return token.keyword.exit
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'd' {
                    if xsrc == "def" {
                        return token.keyword.def
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'r' {
                    if xsrc == "return" {
                        return token.keyword.return
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 't' {
                    if xsrc == "true" {
                        return token.keyword.true
                    }
                    if xsrc == "thread" {
                        return token.keyword.thread
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'f' {
                    if xsrc == "false" {
                        return token.keyword.false
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'n' {
                    if xsrc == "none" {
                        return token.keyword.none
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'm' {
                    if xsrc == "macro" {
                        return token.keyword.macro
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 's' {
                    if xsrc == "static" {
                        return token.keyword.static
                    }
                    return [token.ident, xsrc]
                }
                return [token.ident, xsrc]
            }
        }
    }
    if first == 0 {
        return 0
    }
    puts(str_to_array("bad char: ") ~ [first])
    exit
}
