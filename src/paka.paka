
def put(str) {
    i = 0
    while i < length(str) {
        putchar(str[i])
        i = i + 1
    }
}

def puts(str) {
    put(str)
    putchar(10)
}

def putn_gte0(n) {
    if n >= 10 {
        lowest = n % 10
        putn_gte0((n - lowest) / 10)
        putchar(lowest + 48)
    } else {
        putchar(n % 10 + 48)
    }
}

def putn(n) {
    if n < 0 {
        put("-")
        putn_gte0(0 - n)
    } else {
        putn_gte0(n)
    }
}

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return true
        }
    }
    return false
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return true
    } else {
        return false
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return true
    }
    if char_between(chr, "AZ") {
        return true
    }
    return false
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return true
    }
    if chr == '.' {
        return true
    }
    if chr == '_' {
        return true
    }
    return false
}

def char_id(chr) {
    if char_id0(chr) {
        return true
    }
    if char_isdigit(chr) {
        return true
    }
    return false
}

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def str_to_array(src) {
    ret = []
    i = 0
    while i < length(src) {
        ret ~= [src[i]]
        i = i + 1
    }
    return ret
}

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] >= length(src[0]) {
        return 0
    } else {
        return src[0][src[1]]
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {
        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return false
        }
        i = i + 1
    }
    return true
}

def tokenize_stream1(bsrc, keywords, ops_flat) {
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return ["op", op, bsrc[1]]
        }
        xop = xop + 1
    }
    first = stream_peek(bsrc)
    if first == ' ' {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc, keywords, ops_flat)
    }
    if first == 10 {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc, keywords, ops_flat)
    }
    if first == '#' {
        stream_skip1(bsrc)
        while true {
            cur = stream_read(bsrc)
            if cur == 10 {
                return tokenize_stream1(bsrc, keywords, ops_flat)
            }
        }
    }
    if first == '(' {
        return ["open", stream_read(bsrc), bsrc[1]]
    }
    if first == ')' {
        return ["close", stream_read(bsrc), bsrc[1]]
    }
    if first == '{' {
        return ["open", stream_read(bsrc), bsrc[1]]
    }
    if first == '}' {
        return ["close", stream_read(bsrc), bsrc[1]]
    }
    if first == '[' {
        return ["open", stream_read(bsrc), bsrc[1]]
    }
    if first == ']' {
        return ["close", stream_read(bsrc), bsrc[1]]
    }
    if first == ',' {
        return ["comma", stream_read(bsrc), bsrc[1]]
    }
    if first == ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if cur == "\\"[0] {
            cur = stream_read(bsrc)
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            if cur == 'n' {
                return ["num", 10, bsrc[1]]
            } 
            if cur == "\""[0] {
                return ["num", cur, bsrc[1]]
            }
            if cur == "\\"[0] {
                return ["num", cur, bsrc[1]]
            }
        } else {
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            return ["num", cur, bsrc[1]]
        }
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return ["str", ret, bsrc[1]]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == 'n' {
                    ret ~= [10]
                } 
                if cur == "\""[0] {
                    ret ~= ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret ~= ["\\"[0]]
                }
            } else {
                ret ~= [cur]
            }
        }
        puts("bad char")
        exit
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - '0'
        }
        return ["num", n, bsrc[1]]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc ~= [stream_read(bsrc)]
            } else {
                ki = 0
                while ki < length(keywords) {
                    if str_to_array(keywords[ki]) == xsrc {
                        return [keywords[ki], xsrc, bsrc[1]]
                    }
                    ki = ki + 1
                }
                return ["ident", xsrc, bsrc[1]]
            }
        }
    }
    if first == 0 {
        return 0
    }
    puts(str_to_array("bad char: ") ~ [first])
    exit
}

def tokenize(src) {
    keywords = ["while", "if", "else", "def", "enum", "return", "macro", "exit", "true", "false", "none"]
    ops_flat = ["<=", ">=", "==", "!=", "~=", "=", "~", "+", "-", "%", "*", "/", "<", ">"]
    ssrc = stream_new(src) 
    tokens = []
    while true {
        if stream_peek(ssrc) == 0 {
            return tokens
        }
        token = tokenize_stream1(ssrc, keywords, ops_flat)
        if token == 0 {
            return tokens
        }
        tokens ~= [token]
    }
}

def read_call(tokens, args, state) {
    got = stream_read(tokens)
    if got == 0 {
        puts("error: got eof, wanted `(`")
        exit
    }
    if got[0] != "open" {
        puts("error: wanted `(`")
        exit
    }
    while true {
        cur = stream_peek(tokens)
        if cur == 0 {
            puts("error 1")
            exit
        }
        if cur[0] == "close" {
            stream_skip1(tokens)
            return read_post(tokens, args, state)
        }
        arg = read_expr_base(tokens, state)
        args ~= [arg]
        if stream_peek(tokens)[0] == "comma" {
            stream_skip1(tokens)
        }
    }
}

def read_post(tokens, last, state) {
    first = stream_peek(tokens)
    if first == 0 {
        return last
    }
    if first[0] == "open" {
        if first[1] == '[' {
            stream_skip1(tokens)
            index = read_expr_base(tokens, state)
            stream_skip1(tokens)
            return read_post(tokens, [vm_emit_nameof("index"), last, index], state)
        }
        if first[1] == '(' {
            args = [vm_emit_nameof("call"), last] 
            return read_call(tokens, args, state)
        }
    }
    return last
}

def read_single(tokens, state) {
    first = stream_peek(tokens)
    if first == 0 {
        return none
    }
    if first[0] == "true" {
        stream_skip1(tokens)
        return [vm_emit_nameof("true")]
    }
    if first[0] == ("false") {
        stream_skip1(tokens)
        return [vm_emit_nameof("false")]
    }
    if first[0] == ("none") {
        stream_skip1(tokens)
        return [vm_emit_nameof("none")]
    }
    if first[0] == ("num") {
        stream_skip1(tokens)
        return [vm_emit_nameof("num"), first[1]]
    }
    if first[0] == ("str") {
        stream_skip1(tokens)
        return [vm_emit_nameof("str"), first[1]]
    }
    if first[0] == ("ident") {
        stream_skip1(tokens)
        if first[1] == str_to_array(vm_emit_nameof("exec")) {
            return read_call(tokens, [vm_emit_nameof("exec")], state)
        } 
        if first[1] == str_to_array("putchar") {
            return read_call(tokens, ["putchar"], state)
        } 
        if first[1] == str_to_array(vm_emit_nameof("length")) {
            return read_call(tokens, [vm_emit_nameof("length")], state)
        }
        if first[1] == str_to_array(vm_emit_nameof("dump")) {
            return read_call(tokens, [vm_emit_nameof("dump")], state)
        }
        if first[1] == str_to_array(vm_emit_nameof("write")) {
            return read_call(tokens, [vm_emit_nameof("write")], state)
        }
        if first[1] == str_to_array(vm_emit_nameof("read")) {
            return read_call(tokens, [vm_emit_nameof("read")], state)
        }
        if first[1] == str_to_array(vm_emit_nameof("import")) {
            return read_call(tokens, [vm_emit_nameof("import")], state)
        }
        if first[1] == str_to_array(vm_emit_nameof("type")) {
            return read_call(tokens, [vm_emit_nameof("type")], state)
        } 
        return [vm_emit_nameof("ident"), first[1]]
    }
    if first[0] == "open" {
        if first[1] == '[' {
            stream_skip1(tokens)
            args = [vm_emit_nameof("array")]
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    puts("error 2")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return args
                }
                expr = read_expr_base(tokens, state)
                args ~= [expr]
                if stream_peek(tokens)[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
        if first[1] == '(' {
            stream_skip1(tokens)
            ret = read_expr_base(tokens, state)
            stream_skip1(tokens)
            return ret
        }
    }
    put("@")
    putn(first[2])
    puts("")
    put("error: unexpected ")
    put(first[0])
    put(": `")
    put(first[1])
    put("`")
    puts("")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if op == some[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def read_expr(tokens, depth, state) {
    ops = state[0]
    if depth >= length(ops) {
        return read_post(tokens, read_single(tokens, state), state)
    }
    ret = read_expr(tokens, depth + 1, state)
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] != "op" {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        stream_skip1(tokens)
        ret = [first[1], ret, read_expr(tokens, depth + 1, state)]
    }
}

def read_expr_base(tokens, state) {
    ret = read_expr(tokens, 0, state)
    return ret
}

def read_stmt(tokens, state) {
    first = stream_peek(tokens)
    if first[0] == ("while") {
        stream_skip1(tokens)
        expr = read_expr_base(tokens, state)
        block = read_block(tokens, state)
        return [vm_emit_nameof("while"), expr, block]
    }
    if first[0] == ("def") {
        stream_skip1(tokens)
        expr = read_expr_base(tokens, state)
        block = read_block(tokens, state)
        return [vm_emit_nameof("def"), expr, block]
    }
    if first[0] == ("return") {
        stream_skip1(tokens)
        expr = read_expr_base(tokens, state)
        return [vm_emit_nameof("return"), expr]
    }
    if first[0] == ("macro") {
        stream_skip1(tokens)
        name = stream_read(tokens)
        if name == 0 {
            puts("macro cannot be last word in file")
            exit
        }
        if name[0] != "ident" {
            puts("macro needs to be followed by identifer")
            exit
        }
        expr = read_block(tokens, state)
        return [vm_emit_nameof("macro"), name, expr]
    }
    if first[0] == ("enum") {
        stream_skip1(tokens)
        expr = read_expr_base(tokens, state)
        return [vm_emit_nameof("enum"), expr]
    }
    if first[0] == ("exit") {
        stream_skip1(tokens)
        return [vm_emit_nameof("exit")]
    }
    if first[0] == ("if") {
        stream_skip1(tokens)
        expr = read_expr_base(tokens, state)
        block1 = read_block(tokens, state)
        block2 = [vm_emit_nameof("do")]
        first = stream_peek(tokens)
        if first != 0 {
            if first[0] == "else" {
                stream_skip1(tokens)
                block2 = read_block(tokens, state)
            }
        }
        return [vm_emit_nameof("if"), expr, block1, block2]
    }
    ret = read_expr_base(tokens, state)
    return ret
}

def read_block_body(tokens, state) {
    ret = [vm_emit_nameof("do")]
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] == "close" {
            return ret
        }
        stmt = read_stmt(tokens, state)
        ret ~= [stmt]
    }
}

def read_block(tokens, state) {
    first = stream_peek(tokens)
    if first[0] == "open" {
        stream_skip1(tokens)
        ret = read_block_body(tokens, state)
        stream_skip1(tokens)
        return ret
    }
    put("@")
    putn(first[2])
    puts("")
    puts("parser: block error")
    exit
}

def parse(tokens) {
    xstream = stream_new(tokens)
    ops = [["=", "~="], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"]]
    state = [ops]
    ret = read_block_body(xstream, state)
    return ret
}

def opcode(name) {
    if name == vm_emit_nameof("exit") { return 0 }
    if name == "store_reg" { return 1 }
    if name == "store_none" { return 2 }
    if name == "store_bool" { return 3 }
    if name == "store_int" { return 4 }
    if name == "equal" { return 5 }
    if name == "not_equal" { return 6 }
    if name == "less" { return 7 }
    if name == "greater" { return 8 }
    if name == "less_than_equal" { return 9 }
    if name == "greater_than_equal" { return 10 }
    if name == "jump" { return 11 }
    if name == "branch" { return 12 }
    if name == "add" { return 13 }
    if name == "sub" { return 14 }
    if name == "mul" { return 15 }
    if name == "div" { return 16 }
    if name == "mod" { return 17 }
    if name == "concat" { return 18 }
    if name == "static_call" { return 19 }
    if name == "return" { return 20 }
    if name == "putchar" { return 21 }
    if name == "string_new" { return 22 }
    if name == "array_new" { return 23 }
    if name == "length" { return 24 }
    if name == "index_get" { return 25 }
    if name == "index_set" { return 26 }
    if name == "type" { return 27 }
    if name == "exec" { return 28 }
    if name == "extend" { return 29 }
    if name == "push" { return 30 }
    if name == "dump" { return 31 }
    if name == "read" { return 32 }
    if name == "write" { return 33 }
    puts(str_to_array("unknown opcode: ") ~ name)
    exit
}

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_int"), ret, form[1]]
    return ret
}

def emit_true(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_bool"), ret, 1]
    return ret
}

def emit_false(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_bool"), ret, 0]
    return ret
}

def emit_none(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_none"), ret]
    return ret
}

def emit_binop(op, form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    ret = reg(out)
    out[0] ~= [opcode(op), ret, r1, r2]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] ~= [opcode("putchar"), r1]
    return none
}

def emit_extend(form, out) {
    r1 = emit_to(form[1], out)
    if form[2][0] == vm_emit_nameof("array") {
        i = 1
        while i < length(form[2]) {
            rn = emit_to(form[2][i], out)
            out[0] ~= [opcode("push"), r1, rn] 
            i = i + 1    
        }
    } else {
        r2 = emit_to(form[2], out)
        out[0] ~= [opcode("extend"), r1, r2]
    }
    return r1
}

def emit_exec(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("exec"), r1, r2]
    return none
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("length"), ret, r1]
    return ret
}

def emit_type(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("type"), ret, r1]
    return ret
}

def emit_do(form, out) {
    i = 1
    while i < length(form) {
        emit_to(form[i], out)
        i = i + 1
    } 
    return none
}

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        puts(vars[i][0])
        if vars[i][0] == name {
            return vars[i][1]
        }
        i = i + 1
    }
    return none
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if res != none {
        return res
    }
    res = findvar(out[5], form[1])
    if res != none {
        oreg = reg(out) 
        out[0] ~= [opcode("store_int"), oreg, res]
        return oreg
    }
    puts(str_to_array("undefined ident: ") ~ form[1])
    exit

}

def emit_set(form, out) {
    if form[1][0] == vm_emit_nameof("ident") {
        found = findvar(out[2], form[1][1])
        if found == none {
            from = emit_to(form[2], out)
            to = reg(out)
            out[2] ~= [[form[1][1], to]]
            out[0] ~= [opcode("store_reg"), to, from]
            return to
        } else {
            from = emit_to(form[2], out)
            out[0] ~= [opcode("store_reg"), found, from]
            return found
        }
    }
    if form[1][0] == vm_emit_nameof("index") {
        array = emit_to(form[1][1], out)
        index = emit_to(form[1][2], out)
        from = emit_to(form[2], out)
        out[0] ~= [opcode("index_set"), array, index, from]
        return array
    }
    put("cannot set to: ")
    puts(form[1][0])
    exit
}

def emit_macro(form, out) {
    name = form[1][1]
    idents = []
    where = 1
    while where < length(form[2]) {
        name = form[1][1] ~ ['.'] ~ form[2][where][1]
        out[5] ~= [[name, where]]
        where = where + 1
    }

}

def emit_def(form, out) {
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    i = 2
    while i < length(call) {
        out[2] ~= [[call[i][1], i - 1]]
        i = i + 1
    }
    out[1] = i - 1
    jout = length(out[0]) + 1
    nregs = length(out[0]) + 2
    out[0] ~= [opcode("jump"), "jump", 256]
    out[3] ~= [[call[1][1], length(out[0])]]
    resreg = emit_to(body, out)
    if resreg == none {
        out[0] ~= [opcode("store_none"), 0, opcode("return"), 0]
    } else {
        out[0] ~= [opcode("return"), resreg]
    }
    out[0][nregs] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0][jout] = length(out[0])
    return none
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] ~= [opcode("return"), rreg]
    return none
}

def emit_exit(form, out) {
    out[0] ~= [opcode("exit")]
    return none
}

def emit_call(form, out) {
    regs = []
    i = 2
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("static_call"), ret, form[1][1], length(regs)] ~ regs
    return ret
}

def emit_while(form, out) {
    jredo = length(out[0])
    cond = emit_to(form[1], out)
    sout = length(out[0]) + 2
    sfall = length(out[0]) + 4
    out[0] ~= [opcode("branch"), sfall, "jump", cond]
    emit_to(form[2], out)
    out[0] ~= [opcode("jump"), jredo]
    out[0][sout] = length(out[0])
    return none
}

def emit_if(form, out) {
    cond = emit_to(form[1], out)
    st = length(out[0]) + 1
    sf = length(out[0]) + 2
    out[0] ~= [opcode("branch"), "jump", "jump", cond]
    jt = length(out[0])
    emit_to(form[2], out)
    so1 = length(out[0]) + 1
    out[0] ~= [opcode("jump"), "jump"]
    jf = length(out[0])
    emit_to(form[3], out)
    so2 = length(out[0]) + 1
    out[0] ~= [opcode("jump"), "jump"]
    jout = length(out[0])
    out[0][st] = jt
    out[0][sf] = jf
    out[0][so1] = jout
    out[0][so2] = jout
    return none
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("array_new"), ret, length(regs)] ~ regs
    return ret
}

def emit_str(form, out) {
    chrs = []
    i = 0
    while i < length(form[1]) {
        chrs ~= [form[1][i]]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("string_new"), ret, length(chrs)] ~ chrs
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("dump"), r1, r2]
    return none
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("write"), r1, r2]
    return none
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("read"), ret, r1]
    return ret
}

def emit_import(form, out) {
    src = read(out[4][0] ~ ['/'] ~ str_to_array(form[1][1]))
    if src == none {
        put("cannot find file: ")
        puts(form[1][1])
        exit
    } else {
        tokens = tokenize(src)
        ast = parse(tokens)
        emit_to(ast, out)
        return none
    }
}
def vm_emit_nameof(named) {
    return named
}

def emit_to(form, out) {
    if form[0] == vm_emit_nameof("num") {
        return emit_num(form, out)
    }
    if form[0] == vm_emit_nameof("true") {
        return emit_true(form, out)
    }
    if form[0] == vm_emit_nameof("false") {
        return emit_false(form, out)
    }
    if form[0] == vm_emit_nameof("none") {
        return emit_none(form, out)
    }
    if form[0] == "~=" {
        return emit_extend(form, out)
    }
    if form[0] == "~" {
        return emit_binop("concat", form, out)
    }
    if form[0] == "+" {
        return emit_binop("add", form, out)
    }
    if form[0] == "-" {
        return emit_binop("sub", form, out)
    }
    if form[0] == "*" {
        return emit_binop("mul", form, out)
    }
    if form[0] == "/" {
        return emit_binop("div", form, out)
    }
    if form[0] == "%" {
        return emit_binop("mod", form, out)
    }
    if form[0] == "<" {
        return emit_binop("less", form, out)
    }
    if form[0] == ">" {
        return emit_binop("greater", form, out)
    }
    if form[0] == "<=" {
        return emit_binop("less_than_equal", form, out)
    }
    if form[0] == ">=" {
        return emit_binop("greater_than_equal", form, out)
    }
    if form[0] == "==" {
        return emit_binop("equal", form, out)
    }
    if form[0] == "!=" {
        return emit_binop("not_equal", form, out)
    }
    if form[0] == vm_emit_nameof("index") {
        return emit_binop("index_get", form, out)
    }
    if form[0] == vm_emit_nameof("def") {
        return emit_def(form, out)
    }
    if form[0] == vm_emit_nameof("return") {
        return emit_return(form, out)
    }
    if form[0] == vm_emit_nameof("macro") {
        return emit_macro(form, out)
    }
    if form[0] == vm_emit_nameof("exit") {
        return emit_exit(form, out)
    }
    if form[0] == vm_emit_nameof("call") {
        return emit_call(form, out)
    }
    if form[0] == vm_emit_nameof("ident") {
        return emit_ident(form, out)
    }
    if form[0] == "putchar" {
        return emit_putchar(form, out)
    }
    if form[0] == vm_emit_nameof("exec") {
        return emit_exec(form, out)
    }
    if form[0] == vm_emit_nameof("length") {
        return emit_length(form, out)
    }
    if form[0] == vm_emit_nameof("import") {
        return emit_import(form, out)
    }
    if form[0] == vm_emit_nameof("dump") {
        return emit_dump(form, out)
    }
    if form[0] == vm_emit_nameof("read") {
        return emit_read(form, out)
    }
    if form[0] == vm_emit_nameof("write") {
        return emit_write(form, out)
    }
    if form[0] == vm_emit_nameof("type") {
        return emit_type(form, out)
    }
    if form[0] == vm_emit_nameof("array") {
        return emit_array(form, out)
    }
    if form[0] == vm_emit_nameof("str") {
        return emit_str(form, out)
    }
    if form[0] == vm_emit_nameof("while") {
        return emit_while(form, out)
    }
    if form[0] == vm_emit_nameof("if") {
        return emit_if(form, out)
    }
    if form[0] == "=" {
        return emit_set(form, out)
    }

    if form[0] == vm_emit_nameof("do") {
        return emit_do(form, out)
    }
    puts("unknown form: " ~ form[0])
    exit
}

def emit_link(out) {
    link_type = type([])
    ret = []
    i = 0
    while i < length(out[0]) {
        cur = out[0][i] 
        if type(cur) == link_type {
            func = findvar(out[3], cur)
            if func == none {
                put("link error: undefined: ")
                puts(cur)
                exit
            }
            ret ~= [func]
        } else {
            ret ~= [out[0][i]]
        }
        i = i + 1
    }
    return ret
}

def emit(form, path) {
    out = [[], 0, [[str_to_array("args"), 0]], [], [path, []], path, []]
    emit_to(form, out)
    out[0] ~= [opcode("exit")]
    linked = emit_link(out)
    return linked
}

def file_dir_len(filename) {
    i = length(filename)
    while i > 0 {
        i = i - 1
        if filename[i] == '/' {
            return i
        }
    }
    return 0
}

def file_dir(filename) {
    i = 0
    n = file_dir_len(filename)
    ret = []
    while i < n {
        ret ~= [filename[i]]
        i = i + 1
    }
    return ret
}

def main(argv) {
    run = false
    outfile = "exec.bc"
    srcfile = none
    rest = []
    i = 0
    while i < length(argv) {
        arg = argv[i]
        if run {
            rest ~= [arg]
            i = i + 1
        } else {
            if arg[0] == '-' {
                if arg[1] == '-' {
                    run = true
                } 
                if arg[1] == 'o' {
                    i = i + 1
                    outfile = argv[i]
                }
            } else {
                if srcfile != none {
                    puts("only one source can be provided")
                    exit
                }
                srcfile = arg
            }
            i = i + 1
        }
    }
    if srcfile == none {
        puts("no sources provided")
        exit
    }
    src = read(srcfile)
    if src == none {
        put("no such file: ")
        puts(src)
    }
    tokens = tokenize(src)
    ast = parse(tokens)
    bc = emit(ast, file_dir(srcfile))
    if run {
        exec(bc, rest)
    } else {
        dump(outfile, bc)
    }
}

main(args)
