
def debug_put(str) {
    i = 0
    while i < length(str) {
        putchar(str[i])
        i = i + 1
    }
}

def debug_puts(str) {
    debug_put(str)
    putchar(10)
}

def debug_putn_gte0(n) {
    if n >= 10 {
        lowest = n % 10
        debug_putn_gte0((n - lowest) / 10)
        putchar(lowest + 48)
    } else {
        putchar(n % 10 + 48)
    }
}

def debug_putn(n) {
    if n < 0 {
        debug_put("-")
        debug_putn_gte0(0 - n)
    } else {
        debug_putn_gte0(n)
    }
}

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return true
        }
    }
    return false
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return true
    } else {
        return false
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return true
    }
    if char_between(chr, "AZ") {
        return true
    }
    return false
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return true
    }
    if chr == '_' {
        return true
    }
    return false
}

def char_id(chr) {
    if char_id0(chr) {
        return true
    }
    if char_isdigit(chr) {
        return true
    }
    return false
}

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def str_to_array(src) {
    ret = []
    i = 0
    while i < length(src) {
        ret ~= [src[i]]
        i = i + 1
    }
    return ret
}

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] >= length(src[0]) {
        return 0
    } else {
        return src[0][src[1]]
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {
        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return false
        }
        i = i + 1
    }
    return true
}
## 
def tokenize_stream1(bsrc) {
    keywords = ["while", "if", "else", "def", "return", "exit", "true", "false", "none"]
    ops_flat = ["<=", ">=", "==", "!=", "~=", "=", "~", "+", "-", "%", "*", "/", "<", ">"]
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return ["op", op, bsrc[1]]
        }
        xop = xop + 1
    }
    first = stream_peek(bsrc)
    if first == ' ' {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == "\n"[0] {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc)
    }
    if first == '#' {
        stream_skip1(bsrc)
        while true {
            cur = stream_read(bsrc)
            if cur == "\n"[0] {
                return tokenize_stream1(bsrc)
            }
        }
    }
    if first == '(' {
        return ["open", stream_read(), bsrc[1]]
    }
    if first == ')' {
        return ["close", stream_read(), bsrc[1]]
    }
    if first == '{' {
        return ["open", stream_read(), bsrc[1]]
    }
    if first == '}' {
        return ["close", stream_read(), bsrc[1]]
    }
    if first == '[' {
        return ["open", stream_read(), bsrc[1]]
    }
    if first == ']' {
        return ["close", stream_read(), bsrc[1]]
    }
    if first == ',' {
        return ["comma", stream_read(), bsrc[1]]
    }
    if first == ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if cur == "\\"[0] {
            cur = stream_read(bsrc)
            if stream_read() != ''' {
                debug_puts("unterminated char literal")
                exit
            }
            if cur == 'n' {
                return ["num", "\n"[0], bsrc[1]]
            } 
            if cur == "\""[0] {
                return ["num", cur, bsrc[1]]
            }
            if cur == "\\"[0] {
                return ["num", cur, bsrc[1]]
            }
        } else {
            if stream_read() != ''' {
                debug_puts("unterminated char literal")
                exit
            }
            return ["num", cur, bsrc[1]]
        }
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                debug_puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return ["str", ret, bsrc[1]]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == 'n' {
                    ret ~= ["\n"[0]]
                } 
                if cur == "\""[0] {
                    ret ~= ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret ~= ["\\"[0]]
                }
            } else {
                ret ~= [cur]
            }
        }
        debug_puts("bad char")
        exit
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - '0'
        }
        return ["num", n, bsrc[1]]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc ~= [stream_read(bsrc)]
            } else {
                ki = 0
                while ki < length(keywords) {
                    if str_to_array(keywords[ki]) == xsrc {
                        return [keywords[ki], xsrc, bsrc[1]]
                    }
                    ki = ki + 1
                }
                return ["ident", xsrc, bsrc[1]]
            }
        }
    }
    if first == 0 {
        return 0
    }
    debug_puts(str_to_array("bad char: ") ~ [first])
    exit
}

def tokenize(src) {
    ssrc = stream_new(src) 
    tokens = []
    while true {
        if stream_peek(ssrc) == 0 {
            return tokens
        }
        token = tokenize_stream1(ssrc)
        if token == 0 {
            return tokens
        }
        tokens ~= [token]
    }
}

def read_post(tokens, last) {
    first = stream_peek(tokens)
    if first == 0 {
        return last
    }
    if first[0] == "open" {
        if first[1] == '[' {
            stream_skip1(tokens)
            index = read_expr_base(tokens)
            stream_skip1(tokens)
            return read_post(tokens, ["index", last, index])
        }
        if first[1] == '(' {
            stream_skip1(tokens)
            args = ["call", last]
            if last[0] == "putchar" {
                args = ["putchar"]
            }
            if last[0] == "exec" {
                args = ["exec"]
            }
            if last[0] == "length" {
                args = ["length"]
            }
            if last[0] == "dump" {
                args = ["dump"]
            }
            if last[0] == "import" {
                args = ["import"]
            }
            if last[0] == "read" {
                args = ["read"]
            }
            if last[0] == "write" {
                args = ["write"]
            }
            if last[0] == "type" {
                args = ["type"]
            }
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    debug_puts("error 1")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return read_post(tokens, args)
                }
                arg = read_expr_base(tokens)
                args ~= [arg]
                if stream_peek(tokens)[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
    }
    return last
}

def read_single(tokens) {
    first = stream_peek(tokens)
    if first == 0 {
        return none
    }
    if first[0] == "true" {
        stream_skip1(tokens)
        return ["true"]
    }
    if first[0] == "false" {
        stream_skip1(tokens)
        return ["false"]
    }
    if first[0] == "none" {
        stream_skip1(tokens)
        return ["none"]
    }
    if first[0] == "num" {
        stream_skip1(tokens)
        return ["num", first[1]]
    }
    if first[0] == "str" {
        stream_skip1(tokens)
        return ["str", first[1]]
    }
    if first[0] == "ident" {
        stream_skip1(tokens)
        if first[1] == str_to_array("exec") {
            return ["exec"]
        } 
        if first[1] == str_to_array("putchar") {
            return ["putchar"]
        } 
        if first[1] == str_to_array("length") {
            return ["length"]
        }
        if first[1] == str_to_array("dump") {
            return ["dump"]
        }
        if first[1] == str_to_array("write") {
            return ["write"]
        }
        if first[1] == str_to_array("read") {
            return ["read"]
        }
        if first[1] == str_to_array("import") {
            return ["import"]
        }
        if first[1] == str_to_array("type") {
            return ["type"]
        } 
        return ["ident", first[1]]
    }
    if first[0] == "open" {
        if first[1] == '[' {
            stream_skip1(tokens)
            args = ["array"]
            while true {
                cur = stream_peek(tokens)
                if cur == 0 {
                    debug_puts("error 2")
                    exit
                }
                if cur[0] == "close" {
                    stream_skip1(tokens)
                    return args
                }
                expr = read_expr_base(tokens)
                args ~= [expr]
                if stream_peek(tokens)[0] == "comma" {
                    stream_skip1(tokens)
                }
            } 
        }
        if first[1] == '(' {
            stream_skip1(tokens)
            ret = read_expr_base(tokens)
            stream_skip1(tokens)
            return ret
        }
    }
    debug_put("@")
    debug_putn(first[2])
    debug_puts("")
    debug_put("error: unexpected ")
    debug_put(first[0])
    debug_put(": `")
    debug_put(first[1])
    debug_put("`")
    debug_puts("")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if op == some[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def read_expr(tokens, depth) {
    ops = [["=", "~="], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"]]
    if depth >= length(ops) {
        return read_post(tokens, read_single(tokens))
    }
    ret = read_expr(tokens, depth + 1)
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] != "op" {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        stream_skip1(tokens)
        ret = [first[1], ret, read_expr(tokens, depth + 1)]
    }
}

def read_expr_base(tokens) {
    ret = read_expr(tokens, 0)
    return ret
}

def read_stmt(tokens) {
    first = stream_peek(tokens)
    if first[0] == "while" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block = read_block(tokens)
        return ["while", expr, block]
    }
    if first[0] == "def" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block = read_block(tokens)
        return ["def", expr, block]
    }
    if first[0] == "return" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        return ["return", expr]
    }
    if first[0] == "exit" {
        stream_skip1(tokens)
        return ["exit"]
    }
    if first[0] == "if" {
        stream_skip1(tokens)
        expr = read_expr_base(tokens)
        block1 = read_block(tokens)
        block2 = ["do"]
        first = stream_peek(tokens)
        if first != 0 {
            if first[0] == "else" {
                stream_skip1(tokens)
                block2 = read_block(tokens)
            }
        }
        return ["if", expr, block1, block2]
    }
    ret = read_expr_base(tokens)
    return ret
}

def read_block_body(tokens) {
    ret = ["do"]
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] == "close" {
            return ret
        }
        stmt = read_stmt(tokens)
        ret ~= [stmt]
    }
}

def read_block(tokens) {
    first = stream_peek(tokens)
    if first[0] == "open" {
        stream_skip1(tokens)
        ret = read_block_body(tokens)
        stream_skip1(tokens)
        return ret
    }
    debug_put("@")
    debug_putn(first[2])
    debug_puts("")
    debug_puts("parser: block error")
    exit
}

def parse(tokens) {
    xstream = stream_new(tokens)
    ret = read_block_body(xstream)
    return ret
}

def opcode(name) {
    if name == "exit" { return 0 }
    if name == "store_reg" { return 1 }
    if name == "store_none" { return 2 }
    if name == "store_bool" { return 3 }
    if name == "store_int" { return 4 }
    if name == "equal" { return 5 }
    if name == "not_equal" { return 6 }
    if name == "less" { return 7 }
    if name == "greater" { return 8 }
    if name == "less_than_equal" { return 9 }
    if name == "greater_than_equal" { return 10 }
    if name == "jump" { return 11 }
    if name == "branch" { return 12 }
    if name == "add" { return 13 }
    if name == "sub" { return 14 }
    if name == "mul" { return 15 }
    if name == "div" { return 16 }
    if name == "mod" { return 17 }
    if name == "concat" { return 18 }
    if name == "static_call" { return 19 }
    if name == "return" { return 20 }
    if name == "putchar" { return 21 }
    if name == "string_new" { return 22 }
    if name == "array_new" { return 23 }
    if name == "length" { return 24 }
    if name == "index_get" { return 25 }
    if name == "index_set" { return 26 }
    if name == "type" { return 27 }
    if name == "exec" { return 28 }
    if name == "extend" { return 29 }
    if name == "push" { return 30 }
    if name == "dump" { return 31 }
    if name == "read" { return 32 }
    if name == "write" { return 33 }
    debug_puts(str_to_array("unknown opcode: ") ~ name)
    exit
}

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_int"), ret, form[1]]
    return ret
}

def emit_true(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_bool"), ret, 1]
    return ret
}

def emit_false(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_bool"), ret, 0]
    return ret
}

def emit_none(form, out) {
    ret = reg(out)
    out[0] ~= [opcode("store_none"), ret]
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if res == none {
        debug_puts(str_to_array("compile error: undefined: ") ~ form[1])
        exit
    }
    return res
}

def emit_binop(op, form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    ret = reg(out)
    out[0] ~= [opcode(op), ret, r1, r2]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] ~= [opcode("putchar"), r1]
    return none
}

def emit_extend(form, out) {
    r1 = emit_to(form[1], out)
    if form[2][0] == "array" {
        i = 1
        while i < length(form[2]) {
            rn = emit_to(form[2][i], out)
            out[0] ~= [opcode("push"), r1, rn] 
            i = i + 1    
        }
    } else {
        r2 = emit_to(form[2], out)
        out[0] ~= [opcode("extend"), r1, r2]
    }
    return r1
}

def emit_exec(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("exec"), r1, r2]
    return none
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("length"), ret, r1]
    return ret
}

def emit_type(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("type"), ret, r1]
    return ret
}

def emit_do(form, out) {
    i = 1
    while i < length(form) {
        emit_to(form[i], out)
        i = i + 1
    } 
    return none
}

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        if vars[i][0] == name {
            return vars[i][1]
        }
        i = i + 1
    }
    return none
}

def emit_set(form, out) {
    if form[1][0] == "ident" {
        found = findvar(out[2], form[1][1])
        if found == none {
            from = emit_to(form[2], out)
            to = reg(out)
            out[2] ~= [[form[1][1], to]]
            out[0] ~= [opcode("store_reg"), to, from]
            return to
        } else {
            from = emit_to(form[2], out)
            out[0] ~= [opcode("store_reg"), found, from]
            return found
        }
    }
    if form[1][0] == "index" {
        array = emit_to(form[1][1], out)
        index = emit_to(form[1][2], out)
        from = emit_to(form[2], out)
        out[0] ~= [opcode("index_set"), array, index, from]
        return array
    }
    debug_put("cannot set to: ")
    debug_puts(form[1][0])
    exit
}

def emit_def(form, out) {
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    i = 2
    while i < length(call) {
        out[2] ~= [[call[i][1], i - 1]]
        i = i + 1
    }
    out[1] = i - 1
    jout = length(out[0]) + 1
    nregs = length(out[0]) + 2
    out[0] ~= [opcode("jump"), "jump", 256]
    out[3] ~= [[call[1][1], length(out[0])]]
    resreg = emit_to(body, out)
    if resreg == none {
        out[0] ~= [opcode("store_none"), 0, opcode("return"), 0]
    } else {
        out[0] ~= [opcode("return"), resreg]
    }
    out[0][nregs] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0][jout] = length(out[0])
    return none
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] ~= [opcode("return"), rreg]
    return none
}

def emit_exit(form, out) {
    out[0] ~= [opcode("exit")]
    return none
}

def emit_call(form, out) {
    regs = []
    i = 2
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("static_call"), ret, form[1][1], length(regs)] ~ regs
    return ret
}

def emit_while(form, out) {
    jredo = length(out[0])
    cond = emit_to(form[1], out)
    sout = length(out[0]) + 2
    sfall = length(out[0]) + 4
    out[0] ~= [opcode("branch"), sfall, "jump", cond]
    emit_to(form[2], out)
    out[0] ~= [opcode("jump"), jredo]
    out[0][sout] = length(out[0])
    return none
}

def emit_if(form, out) {
    cond = emit_to(form[1], out)
    st = length(out[0]) + 1
    sf = length(out[0]) + 2
    out[0] ~= [opcode("branch"), "jump", "jump", cond]
    jt = length(out[0])
    emit_to(form[2], out)
    so1 = length(out[0]) + 1
    out[0] ~= [opcode("jump"), "jump"]
    jf = length(out[0])
    emit_to(form[3], out)
    so2 = length(out[0]) + 1
    out[0] ~= [opcode("jump"), "jump"]
    jout = length(out[0])
    out[0][st] = jt
    out[0][sf] = jf
    out[0][so1] = jout
    out[0][so2] = jout
    return none
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("array_new"), ret, length(regs)] ~ regs
    return ret
}

def emit_str(form, out) {
    chrs = []
    i = 0
    while i < length(form[1]) {
        chrs ~= [form[1][i]]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode("string_new"), ret, length(chrs)] ~ chrs
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("dump"), r1, r2]
    return none
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode("write"), r1, r2]
    return none
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode("read"), ret, r1]
    return ret
}

def emit_import(form, out) {
    src = read(out[4][0] ~ ['/'] ~ str_to_array(form[1][1]))
    if src == none {
        debug_put("cannot find file: ")
        debug_puts(form[1][1])
        exit
    } else {
        tokens = tokenize(src)
        ast = parse(tokens)
        emit_to(ast, out)
        return none
    }
}

def emit_to(form, out) {
    if form[0] == "num" {
        return emit_num(form, out)
    }
    if form[0] == "true" {
        return emit_true(form, out)
    }
    if form[0] == "false" {
        return emit_false(form, out)
    }
    if form[0] == "none" {
        return emit_none(form, out)
    }
    if form[0] == "~=" {
        return emit_extend(form, out)
    }
    if form[0] == "~" {
        return emit_binop("concat", form, out)
    }
    if form[0] == "+" {
        return emit_binop("add", form, out)
    }
    if form[0] == "-" {
        return emit_binop("sub", form, out)
    }
    if form[0] == "*" {
        return emit_binop("mul", form, out)
    }
    if form[0] == "/" {
        return emit_binop("div", form, out)
    }
    if form[0] == "%" {
        return emit_binop("mod", form, out)
    }
    if form[0] == "<" {
        return emit_binop("less", form, out)
    }
    if form[0] == ">" {
        return emit_binop("greater", form, out)
    }
    if form[0] == "<=" {
        return emit_binop("less_than_equal", form, out)
    }
    if form[0] == ">=" {
        return emit_binop("greater_than_equal", form, out)
    }
    if form[0] == "==" {
        return emit_binop("equal", form, out)
    }
    if form[0] == "!=" {
        return emit_binop("not_equal", form, out)
    }
    if form[0] == "index" {
        return emit_binop("index_get", form, out)
    }
    if form[0] == "def" {
        return emit_def(form, out)
    }
    if form[0] == "return" {
        return emit_return(form, out)
    }
    if form[0] == "exit" {
        return emit_exit(form, out)
    }
    if form[0] == "call" {
        return emit_call(form, out)
    }
    if form[0] == "ident" {
        return emit_ident(form, out)
    }
    if form[0] == "putchar" {
        return emit_putchar(form, out)
    }
    if form[0] == "exec" {
        return emit_exec(form, out)
    }
    if form[0] == "length" {
        return emit_length(form, out)
    }
    if form[0] == "import" {
        return emit_import(form, out)
    }
    if form[0] == "dump" {
        return emit_dump(form, out)
    }
    if form[0] == "read" {
        return emit_read(form, out)
    }
    if form[0] == "write" {
        return emit_write(form, out)
    }
    if form[0] == "type" {
        return emit_type(form, out)
    }
    if form[0] == "array" {
        return emit_array(form, out)
    }
    if form[0] == "str" {
        return emit_str(form, out)
    }
    if form[0] == "while" {
        return emit_while(form, out)
    }
    if form[0] == "if" {
        return emit_if(form, out)
    }
    if form[0] == "=" {
        return emit_set(form, out)
    }
    if form[0] == "do" {
        return emit_do(form, out)
    }
    debug_puts("unknwon form: " ~ form[0])
    exit
}

def emit_link(out) {
    link_type = type([])
    ret = []
    i = 0
    while i < length(out[0]) {
        cur = out[0][i] 
        if type(cur) == link_type {
            func = findvar(out[3], cur)
            if func == none {
                debug_put("link error: undefined: ")
                debug_puts(cur)
                exit
            }
            ret ~= [func]
        } else {
            ret ~= [out[0][i]]
        }
        i = i + 1
    }
    return ret
}

def emit(form, path) {
    out = [[], 0, [[str_to_array("args"), 0]], [], [path, []]]
    emit_to(form, out)
    out[0] ~= [opcode("exit")]
    linked = emit_link(out)
    return linked
}

def file_dir_len(filename) {
    i = length(filename)
    while i > 0 {
        i = i - 1
        if filename[i] == '/' {
            return i
        }
    }
    return 0
}

def file_dir(filename) {
    i = 0
    n = file_dir_len(filename)
    ret = []
    while i < n {
        ret ~= [filename[i]]
        i = i + 1
    }
    return ret
}

def main(argv) {
    run = false
    outfile = "exec.bc"
    srcfile = none
    rest = []
    i = 0
    while i < length(argv) {
        arg = argv[i]
        if run {
            rest ~= [arg]
            i = i + 1
        } else {
            if arg[0] == '-' {
                if arg[1] == '-' {
                    run = true
                } 
                if arg[1] == 'o' {
                    i = i + 1
                    outfile = argv[i]
                }
            } else {
                if srcfile != none {
                    debug_puts("only one source can be provided")
                    exit
                }
                srcfile = arg
            }
            i = i + 1
        }
    }
    if srcfile == none {
        debug_puts("no sources provided")
        exit
    }
    src = read(srcfile)
    if src == none {
        debug_put("no such file: ")
        debug_puts(src)
    }
    tokens = tokenize(src)
    ast = parse(tokens)
    bc = emit(ast, file_dir(srcfile))
    if run {
        exec(bc, rest)
    } else {
        dump(outfile, bc)
    }
}

main(args)
