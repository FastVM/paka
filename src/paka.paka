
macro vm {
    ast.num
    ast.true
    ast.false
    ast.none
    ast.index
    ast.def
    ast.return
    ast.macro
    ast.exit
    ast.call
    ast.ident
    ast.exec
    ast.length
    ast.import
    ast.dump
    ast.read
    ast.write
    ast.type
    ast.array
    ast.str
    ast.while
    ast.if
    ast.do
    ast.index
    ast.putchar
    ast.enum
}

macro opcode {
    do_store_reg
    do_store_none
    do_store_bool
    do_store_int
    do_equal
    do_not_equal
    do_less
    do_greater
    do_less_than_equal
    do_greater_than_equal
    do_jump
    do_branch
    do_add
    do_sub
    do_mul
    do_div
    do_mod
    do_concat
    do_static_call
    do_return
    do_putchar
    do_string_new
    do_array_new
    do_length
    do_index_get
    do_index_set
    do_type
    do_exec
    do_extend
    do_push
    do_dump
    do_read
    do_write
}

macro token {
    open
    close
    op
    str
    num
    ident
    comma
    keyword
}

def put(str) {
    i = 0
    while i < length(str) {
        putchar(str[i])
        i = i + 1
    }
}

def puts(str) {
    put(str)
    putchar(10)
}

def putn_gte0(n) {
    if n >= 10 {
        lowest = n % 10
        putn_gte0((n - lowest) / 10)
        putchar(lowest + 48)
    } else {
        putchar(n % 10 + 48)
    }
}

def putn(n) {
    if n < 0 {
        put("-")
        putn_gte0(0 - n)
    } else {
        putn_gte0(n)
    }
}

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return true
        }
    }
    return false
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return true
    } else {
        return false
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return true
    }
    if char_between(chr, "AZ") {
        return true
    }
    return false
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return true
    }
    if chr == '.' {
        return true
    }
    if chr == '_' {
        return true
    }
    return false
}

def char_id(chr) {
    if char_id0(chr) {
        return true
    }
    if char_isdigit(chr) {
        return true
    }
    return false
}

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def str_to_array(src) {
    ret = []
    i = 0
    while i < length(src) {
        ret ~= [src[i]]
        i = i + 1
    }
    return ret
}

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] >= length(src[0]) {
        return 0
    } else {
        return src[0][src[1]]
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {
        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return false
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return false
        }
        i = i + 1
    }
    return true
}

def tokenize_stream1(bsrc, keywords, ops_flat) {
    xop = 0
    while xop < length(ops_flat) {
        op = ops_flat[xop]
        if stream_starts_swith(bsrc, op) {
            stream_skip(bsrc, length(op))
            return [token.op, op, bsrc[1]]
        }
        xop = xop + 1
    }
    first = stream_peek(bsrc)
    if first == ' ' {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc, keywords, ops_flat)
    }
    if first == 10 {
        stream_skip1(bsrc)
        return tokenize_stream1(bsrc, keywords, ops_flat)
    }
    if first == '#' {
        stream_skip1(bsrc)
        while true {
            cur = stream_read(bsrc)
            if cur == 10 {
                return tokenize_stream1(bsrc, keywords, ops_flat)
            }
        }
    }
    if first == '(' {
        return [token.open, stream_read(bsrc), bsrc[1]]
    }
    if first == ')' {
        return [token.close, stream_read(bsrc), bsrc[1]]
    }
    if first == '{' {
        return [token.open, stream_read(bsrc), bsrc[1]]
    }
    if first == '}' {
        return [token.close, stream_read(bsrc), bsrc[1]]
    }
    if first == '[' {
        return [token.open, stream_read(bsrc), bsrc[1]]
    }
    if first == ']' {
        return [token.close, stream_read(bsrc), bsrc[1]]
    }
    if first == ',' {
        return [token.comma, stream_read(bsrc), bsrc[1]]
    }
    if first == ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if cur == "\\"[0] {
            cur = stream_read(bsrc)
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            if cur == 'n' {
                return [token.num, 10, bsrc[1]]
            } 
            if cur == "\""[0] {
                return [token.num, cur, bsrc[1]]
            }
            if cur == "\\"[0] {
                return [token.num, cur, bsrc[1]]
            }
        } else {
            if stream_read() != ''' {
                puts("unterminated char literal")
                exit
            }
            return [token.num, cur, bsrc[1]]
        }
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while true {
            cur = stream_read(bsrc)
            if cur == 0 {
                puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return [token.str, ret, bsrc[1]]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == 'n' {
                    ret ~= [10]
                } 
                if cur == "\""[0] {
                    ret ~= ["\""[0]]
                }
                if cur == "\\"[0] {
                    ret ~= ["\\"[0]]
                }
            } else {
                ret ~= [cur]
            }
        }
        puts("bad char")
        exit
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - '0'
        }
        return [token.num, n, bsrc[1]]
    }
    if char_id0(first) {
        xsrc = []
        while true {
            if char_id(stream_peek(bsrc)) {
                xsrc ~= [stream_read(bsrc)]
            } else {
                ki = 0
                while ki < length(keywords) {
                    if str_to_array(keywords[ki]) == xsrc {
                        return [token.keyword, xsrc, bsrc[1]]
                    }
                    ki = ki + 1
                }
                return [token.ident, xsrc, bsrc[1]]
            }
        }
    }
    if first == 0 {
        return 0
    }
    puts(str_to_array("bad char: ") ~ [first])
    exit
}

def tokenize(src) {
    keywords = ["while", "if", "else", "def", "enum", "return", "macro", "exit", "true", "false", "none"]
    ops_flat = ["<=", ">=", "==", "!=", "~=", "=", "~", "+", "-", "%", "*", "/", "<", ">"]
    ssrc = stream_new(src) 
    tokens = []
    while true {
        if stream_peek(ssrc) == 0 {
            return tokens
        }
        token = tokenize_stream1(ssrc, keywords, ops_flat)
        if token == 0 {
            return tokens
        }
        tokens ~= [token]
    }
}

def read_call(tokens, args, state) {
    got = stream_read(tokens)
    if got == 0 {
        puts("error: got eof, wanted `(`")
        exit
    }
    if got[0] != token.open {
        puts("error: wanted `(`")
        exit
    }
    while true {
        cur = stream_peek(tokens)
        if cur == 0 {
            puts("error 1")
            exit
        }
        if cur[0] == token.close {
            stream_skip1(tokens)
            return read_post(tokens, args, state)
        }
        arg = read_expr_base(tokens, state)
        args ~= [arg]
        if stream_peek(tokens)[0] == token.comma {
            stream_skip1(tokens)
        }
    }
}

def read_post(tokens, last, state) {
    first = stream_peek(tokens)
    if first == 0 {
        return last
    }
    if first[0] == token.open {
        if first[1] == '[' {
            stream_skip1(tokens)
            index = read_expr_base(tokens, state)
            stream_skip1(tokens)
            return read_post(tokens, [vm.ast.index, last, index], state)
        }
        if first[1] == '(' {
            args = [vm.ast.call, last] 
            return read_call(tokens, args, state)
        }
    }
    return last
}

def read_single(tokens, state) {
    first = stream_peek(tokens)
    if first == 0 {
        return none
    }
    if first[0] == (token.num) {
        stream_skip1(tokens)
        return [vm.ast.num, first[1]]
    }
    if first[0] == (token.str) {
        stream_skip1(tokens)
        return [vm.ast.str, first[1]]
    }
    if first[0] == (token.ident) {
        stream_skip1(tokens)
        if first[1] == "exec" {
            return read_call(tokens, [vm.ast.exec], state)
        } 
        if first[1] == "putchar" {
            return read_call(tokens, [vm.ast.putchar], state)
        } 
        if first[1] == "length" {
            return read_call(tokens, [vm.ast.length], state)
        }
        if first[1] == "dump" {
            return read_call(tokens, [vm.ast.dump], state)
        }
        if first[1] == "write" {
            return read_call(tokens, [vm.ast.write], state)
        }
        if first[1] == "read" {
            return read_call(tokens, [vm.ast.read], state)
        }
        if first[1] == "import" {
            return read_call(tokens, [vm.ast.import], state)
        }
        if first[1] == "type" {
            return read_call(tokens, [vm.ast.type], state)
        } 
        return [vm.ast.ident, first[1]]
    }
    if first[0] == token.open {
        if first[1] == '[' {
            stream_skip1(tokens)
            args = [vm.ast.array]
            while true {
                cur = stream_peek(tokens)
                if cur[0] == token.close {
                    stream_skip1(tokens)
                    return args
                }
                expr = read_expr_base(tokens, state)
                args ~= [expr]
                if stream_peek(tokens)[0] == token.comma {
                    stream_skip1(tokens)
                }
            } 
        }
        if first[1] == '(' {
            stream_skip1(tokens)
            ret = read_expr_base(tokens, state)
            stream_skip1(tokens)
            return ret
        }
    }
    if first[0] == token.keyword {
        if first[1] == "true" {
            stream_skip1(tokens)
            return [vm.ast.true]
        }
        if first[1] == ("false") {
            stream_skip1(tokens)
            return [vm.ast.false]
        }
        if first[1] == ("none") {
            stream_skip1(tokens)
            return [vm.ast.none]
        }
    }
    put("error: unexpected ")
    putn(first[0])
    put(": `")
    put(first[1])
    put("`")
    puts("")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if op == some[i] {
            return false
        }
        i = i + 1
    }
    return true
}

def read_expr(tokens, depth, state) {
    ops = state[0]
    if depth >= length(ops) {
        return read_post(tokens, read_single(tokens, state), state)
    }
    ret = read_expr(tokens, depth + 1, state)
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] != token.op {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        stream_skip1(tokens)
        ret = [first[1], ret, read_expr(tokens, depth + 1, state)]
    }
}

def read_expr_base(tokens, state) {
    ret = read_expr(tokens, 0, state)
    return ret
}

def read_stmt(tokens, state) {
    first = stream_peek(tokens)
    if first[0] == token.keyword {
        if first[1] == "while" {
            stream_skip1(tokens)
            expr = read_expr_base(tokens, state)
            block = read_block(tokens, state)
            return [vm.ast.while, expr, block]
        }
        if first[1] == "def" {
            stream_skip1(tokens)
            expr = read_expr_base(tokens, state)
            block = read_block(tokens, state)
            return [vm.ast.def, expr, block]
        }
        if first[1] == "return" {
            stream_skip1(tokens)
            expr = read_expr_base(tokens, state)
            return [vm.ast.return, expr]
        }
        if first[1] == "macro" {
            stream_skip1(tokens)
            name = stream_read(tokens)
            if name[0] != token.ident {
                puts("macro needs to be followed by identifer")
                exit
            }
            expr = read_block(tokens, state)
            return [vm.ast.macro, name, expr]
        }
        if first[1] == "enum" {
            stream_skip1(tokens)
            expr = read_expr_base(tokens, state)
            return [vm.ast.enum, expr]
        }
        if first[1] == "exit" {
            stream_skip1(tokens)
            return [vm.ast.exit]
        }
        if first[1] == "if" {
            stream_skip1(tokens)
            expr = read_expr_base(tokens, state)
            block1 = read_block(tokens, state)
            block2 = [vm.ast.do]
            first = stream_peek(tokens)
            if first[0] == token.keyword {
                if first[1] == "else" {
                    stream_skip1(tokens)
                    block2 = read_block(tokens, state)
                }
            }
            return [vm.ast.if, expr, block1, block2]
        }
    } else {
        ret = read_expr_base(tokens, state)
        return ret
    }
}

def read_block_body(tokens, state) {
    ret = [vm.ast.do]
    while true {
        first = stream_peek(tokens)
        if first == 0 {
            return ret
        }
        if first[0] == token.close {
            return ret
        }
        stmt = read_stmt(tokens, state)
        ret ~= [stmt]
    }
}

def read_block(tokens, state) {
    first = stream_peek(tokens)
    if first[0] == token.open {
        stream_skip1(tokens)
        ret = read_block_body(tokens, state)
        stream_skip1(tokens)
        return ret
    }
    put("@")
    putn(first[2])
    puts("")
    puts("parser: block error")
    exit
}

def parse(tokens) {
    xstream = stream_new(tokens)
    ops = [["=", "~="], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"]]
    state = [ops]
    ret = read_block_body(xstream, state)
    return ret
}

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] ~= [opcode.do_store_int, ret, form[1]]
    return ret
}

def emit_true(form, out) {
    ret = reg(out)
    out[0] ~= [opcode.do_store_bool, ret, 1]
    return ret
}

def emit_false(form, out) {
    ret = reg(out)
    out[0] ~= [opcode.do_store_bool, ret, 0]
    return ret
}

def emit_none(form, out) {
    ret = reg(out)
    out[0] ~= [opcode.do_store_none, ret]
    return ret
}

def emit_binop(op, form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    ret = reg(out)
    out[0] ~= [op, ret, r1, r2]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] ~= [opcode.do_putchar, r1]
    return none
}

def emit_extend(form, out) {
    r1 = emit_to(form[1], out)
    if form[2][0] == vm.ast.array {
        i = 1
        while i < length(form[2]) {
            rn = emit_to(form[2][i], out)
            out[0] ~= [opcode.do_push, r1, rn] 
            i = i + 1    
        }
    } else {
        r2 = emit_to(form[2], out)
        out[0] ~= [opcode.do_extend, r1, r2]
    }
    return r1
}

def emit_exec(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode.do_exec, r1, r2]
    return none
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode.do_length, ret, r1]
    return ret
}

def emit_type(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode.do_type, ret, r1]
    return ret
}

def emit_do(form, out) {
    i = 1
    while i < length(form) {
        emit_to(form[i], out)
        i = i + 1
    } 
    return none
}

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        if vars[i] == name {
            return vars[i + 1]
        }
        i = i + 2
    }
    return none
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if res != none {
        return res
    }
    res = findvar(out[5], form[1])
    if res != none {
        oreg = reg(out)
        out[0] ~= [opcode.do_store_int, oreg, res]
        return oreg
    }
    puts(str_to_array("undefined ident: ") ~ form[1])
    exit

}

def emit_set(form, out) {
    if form[1][0] == vm.ast.ident {
        found = findvar(out[2], form[1][1])
        if found == none {
            from = emit_to(form[2], out)
            to = reg(out)
            out[2] ~= [form[1][1], to]
            out[0] ~= [opcode.do_store_reg, to, from]
            return to
        } else {
            from = emit_to(form[2], out)
            out[0] ~= [opcode.do_store_reg, found, from]
            return found
        }
    }
    if form[1][0] == vm.ast.index {
        array = emit_to(form[1][1], out)
        index = emit_to(form[1][2], out)
        from = emit_to(form[2], out)
        out[0] ~= [opcode.do_index_set, array, index, from]
        return array
    }
    put("cannot set to: ")
    puts(form[1][0])
    exit
}

def emit_macro(form, out) {
    name = form[1][1]
    idents = []
    where = 1
    while where < length(form[2]) {
        name = form[1][1] ~ ['.'] ~ form[2][where][1]
        out[5] ~= [name, where]
        where = where + 1
    }
}

def emit_def(form, out) {
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    i = 2
    while i < length(call) {
        out[2] ~= [call[i][1], i - 1]
        i = i + 1
    }
    out[1] = i - 1
    jout = length(out[0]) + 1
    nregs = length(out[0]) + 2
    out[0] ~= [opcode.do_jump, 0, 256]
    out[3] ~= [call[1][1], length(out[0])]
    resreg = emit_to(body, out)
    if resreg == none {
        out[0] ~= [opcode.do_store_none, 0, opcode.do_return, 0]
    } else {
        out[0] ~= [opcode.do_return, resreg]
    }
    out[0][nregs] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0][jout] = length(out[0])
    return none
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] ~= [opcode.do_return, rreg]
    return none
}

def emit_exit(form, out) {
    out[0] ~= [0]
    return none
}

def emit_call(form, out) {
    regs = []
    i = 2
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode.do_static_call, ret, form[1][1], length(regs)] ~ regs
    return ret
}

def emit_while(form, out) {
    jredo = length(out[0])
    cond = emit_to(form[1], out)
    sout = length(out[0]) + 2
    sfall = length(out[0]) + 4
    out[0] ~= [opcode.do_branch, sfall, 0, cond]
    emit_to(form[2], out)
    out[0] ~= [opcode.do_jump, jredo]
    out[0][sout] = length(out[0])
    return none
}

def emit_if(form, out) {
    cond = emit_to(form[1], out)
    st = length(out[0]) + 1
    sf = length(out[0]) + 2
    out[0] ~= [opcode.do_branch, 0, 0, cond]
    jt = length(out[0])
    emit_to(form[2], out)
    so1 = length(out[0]) + 1
    out[0] ~= [opcode.do_jump, 0]
    jf = length(out[0])
    emit_to(form[3], out)
    so2 = length(out[0]) + 1
    out[0] ~= [opcode.do_jump, 0]
    jout = length(out[0])
    out[0][st] = jt
    out[0][sf] = jf
    out[0][so1] = jout
    out[0][so2] = jout
    return none
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs ~= [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode.do_array_new, ret, length(regs)] ~ regs
    return ret
}

def emit_str(form, out) {
    chrs = []
    i = 0
    while i < length(form[1]) {
        chrs ~= [form[1][i]]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [opcode.do_string_new, ret, length(chrs)] ~ chrs
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode.do_dump, r1, r2]
    return none
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] ~= [opcode.do_write, r1, r2]
    return none
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] ~= [opcode.do_read, ret, r1]
    return ret
}

def emit_import(form, out) {
    src = read(out[4][0] ~ ['/'] ~ str_to_array(form[1][1]))
    if src == none {
        put("cannot find file: ")
        puts(form[1][1])
        exit
    } else {
        tokens = tokenize(src)
        ast = parse(tokens)
        emit_to(ast, out)
        return none
    }
}
def vm_emit_nameof(named) {
    return named
}

def emit_to(form, out) {
    if form[0] == vm.ast.num {
        return emit_num(form, out)
    }
    if form[0] == vm.ast.true {
        return emit_true(form, out)
    }
    if form[0] == vm.ast.false {
        return emit_false(form, out)
    }
    if form[0] == vm.ast.none {
        return emit_none(form, out)
    }
    if form[0] == vm.ast.index {
        return emit_binop(opcode.do_index_get, form, out)
    }
    if form[0] == vm.ast.def {
        return emit_def(form, out)
    }
    if form[0] == vm.ast.return {
        return emit_return(form, out)
    }
    if form[0] == vm.ast.macro {
        return emit_macro(form, out)
    }
    if form[0] == vm.ast.exit {
        return emit_exit(form, out)
    }
    if form[0] == vm.ast.call {
        return emit_call(form, out)
    }
    if form[0] == vm.ast.ident {
        return emit_ident(form, out)
    }
    if form[0] == vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if form[0] == vm.ast.exec {
        return emit_exec(form, out)
    }
    if form[0] == vm.ast.length {
        return emit_length(form, out)
    }
    if form[0] == vm.ast.import {
        return emit_import(form, out)
    }
    if form[0] == vm.ast.dump {
        return emit_dump(form, out)
    }
    if form[0] == vm.ast.read {
        return emit_read(form, out)
    }
    if form[0] == vm.ast.write {
        return emit_write(form, out)
    }
    if form[0] == vm.ast.type {
        return emit_type(form, out)
    }
    if form[0] == vm.ast.array {
        return emit_array(form, out)
    }
    if form[0] == vm.ast.str {
        return emit_str(form, out)
    }
    if form[0] == vm.ast.while {
        return emit_while(form, out)
    }
    if form[0] == vm.ast.if {
        return emit_if(form, out)
    }
    if form[0] == vm.ast.do {
        return emit_do(form, out)
    }
    if form[0] == "=" {
        return emit_set(form, out)
    }
    if form[0] == "~=" {
        return emit_extend(form, out)
    }
    if form[0] == "~" {
        return emit_binop(opcode.do_concat, form, out)
    }
    if form[0] == "+" {
        return emit_binop(opcode.do_add, form, out)
    }
    if form[0] == "-" {
        return emit_binop(opcode.do_sub, form, out)
    }
    if form[0] == "*" {
        return emit_binop(opcode.do_mul, form, out)
    }
    if form[0] == "/" {
        return emit_binop(opcode.do_div, form, out)
    }
    if form[0] == "%" {
        return emit_binop(opcode.do_mod, form, out)
    }
    if form[0] == "<" {
        return emit_binop(opcode.do_less, form, out)
    }
    if form[0] == ">" {
        return emit_binop(opcode.do_greater, form, out)
    }
    if form[0] == "<=" {
        return emit_binop(opcode.do_less_than_equal, form, out)
    }
    if form[0] == ">=" {
        return emit_binop(opcode.do_greater_than_equal, form, out)
    }
    if form[0] == "==" {
        return emit_binop(opcode.do_equal, form, out)
    }
    if form[0] == "!=" {
        return emit_binop(opcode.do_not_equal, form, out)
    }
    puts("unknown form: " ~ form[0])
    exit
}

def emit_link(out) {
    link_type = type([])
    ret = []
    i = 0
    while i < length(out[0]) {
        cur = out[0][i] 
        if type(cur) == link_type {
            func = findvar(out[3], cur)
            if func == none {
                put("link error: undefined: ")
                puts(cur)
                exit
            }
            ret ~= [func]
        } else {
            ret ~= [out[0][i]]
        }
        i = i + 1
    }
    return ret
}

def emit(form, path) {
    out = [[], 0, [str_to_array("args"), 0], [], [path, []], []]
    emit_to(form, out)
    out[0] ~= [0]
    linked = emit_link(out)
    return linked
}

def file_dir_len(filename) {
    i = length(filename)
    while i > 0 {
        i = i - 1
        if filename[i] == '/' {
            return i
        }
    }
    return 0
}

def file_dir(filename) {
    i = 0
    n = file_dir_len(filename)
    ret = []
    while i < n {
        ret ~= [filename[i]]
        i = i + 1
    }
    return ret
}

def main(argv) {
    run = false
    outfile = "exec.bc"
    srcfile = none
    rest = []
    i = 0
    while i < length(argv) {
        arg = argv[i]
        if run {
            rest ~= [arg]
            i = i + 1
        } else {
            if arg[0] == '-' {
                if arg[1] == '-' {
                    run = true
                } 
                if arg[1] == 'o' {
                    i = i + 1
                    outfile = argv[i]
                }
            } else {
                if srcfile != none {
                    puts("only one source can be provided")
                    exit
                }
                srcfile = arg
            }
            i = i + 1
        }
    }
    if srcfile == none {
        puts("no sources provided")
        exit
    }
    src = read(srcfile)
    if src == none {
        put("no such file: ")
        puts(src)
    }
    tokens = tokenize(src)
    ast = parse(tokens)
    bc = emit(ast, file_dir(srcfile))
    if run {
        exec(bc, rest)
    } else {
        dump(outfile, bc)
    }
}

main(args)
