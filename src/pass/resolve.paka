
def pass_macro_resolve_copy(form, state) {
    ret = [form[0]]
    i = 1
    while i < length(form) {
        ret = ret ~ [pass_macro_resolve(form[i], state)]
        i = i + 1
    }
    return ret
}

def pass_macro_resolve_macro(form, state) {
    name = form[1][1]
    idents = []
    where = 1
    while where < length(form[2]) {
        ok = 0
        if form[2][where][0] == vm.ast.ident {
            fullname = form[1][1] ~ ['.'] ~ form[2][where][1]
            ast = [vm.ast.num, where]
            state[0] = state[0] ~ [fullname, ast]
            ok = 1
        }
        if form[2][where][0] == vm.ast.op {
            if str.eq(form[2][where][1], "=") {
                setto = form[2][where][2]
                val = form[2][where][3]
                if setto[0] != vm.ast.ident {
                    puts("enum macro given bad value on left hand size of `=`")
                    exit
                }
                fullname = form[1][1] ~ ['.'] ~ setto[1]
                state[0] = state[0] ~ [fullname, val]
                ok = 1
            }
        }
        if ok == 0 {
            puts("that is not valid in a macro")
            exit
        }
        where = where + 1
    }
    return [vm.ast.do]
}

def pass_macro_resolve(form, state) {
    ty = form[0]
    if util_ast_is_literal(ty) {
        return form
    }
    if ty == vm.ast.ident {
        val = findvar(state[0], form[1])
        if length(val) != 0 {
            return val[0]
        }
        return form
    }
    if ty == vm.ast.op {
        return [ty, form[1], pass_macro_resolve(form[2], state), pass_macro_resolve(form[3], state)]
    }
    if ty == vm.ast.enum {
        return pass_macro_resolve_macro(form, state)
    }
    if ty == vm.ast.def {
        return pass_macro_resolve_copy(form, state)
    }
    return pass_macro_resolve_copy(form, state)
}