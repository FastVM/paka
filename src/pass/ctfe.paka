
## TODO: make macros handled in here

def pass_ctfe_ident(form, state) {
    ret = findvar(state[1], form[1])
    if ret != none {
        return ret
    }
    ret = findvar(state[0], form[1])
    if ret == none {
        put("ctfe: undefined ident: ")
        puts(ret)
        exit
    }
    if ret == vm.ast.def {
        put("ctfe: undefined ident (valid function though): ")
        puts(ret)
        exit
    }
    return pass_ctfe_real(ret, state)
}

def pass_ctfe_index(form, state) {
    arr = pass_ctfe_real(form[1], state)
    ind = pass_ctfe_real(form[2], state)
    if type(arr) != type([]) {
        puts("ctfe: attempt to index non-array")
        exit
    }
    if ind < 0 {
        ind = ind + length(arr)
    }
    if ind >= length(arr) {
        puts("ctfe: index out of bounds: too high")
        exit
    }
    if ind < 0 {
        puts("ctfe: index out of bounds: too low")
        exit
    }
    ret = arr[ind]
    return ret
}

def pass_ctfe_length(form, state) {
    arr = pass_ctfe_real(form[1], state)
    if type(arr) != type([]) {
        puts("ctfe: attempt to find length of non-array")
        exit
    }
    ret = length(arr)
    return ret
}

def pass_ctfe_array(form, state) {
    arr = []
    i = 1
    while i < length(form) {
        arr ~= pass_ctfe_real(form[i], state)
        i = i + 1
    }
    return arr
}

def pass_ctfe_while(form, state) {
    while true {
        cond = pass_ctfe_real(form[1], state)
        if cond == false {
            return none
        }
        then = pass_ctfe_real(form[2], state)
        if state[2] != ctfe.state.run {
            return none
        }
    }
}

def pass_ctfe_foreach(form, state) {
    puts("error: ctfe foreach: go yell at shaw to fix foeach")
    exit
}

def pass_ctfe_if(form, state) {
    cond = pass_ctfe_real(form[1], state)
    if cond {
        pass_ctfe_real(form[2], state)
    } else {
        pass_ctfe_real(form[3], state)
    }
    return none
}

def pass_ctfe_set(form, state) {
    if form[1][0] == vm.ast.ident {
        vars = state[1]
        name = form[1][1]
        setto = pass_ctfe_real(form[2])
        i = 0
        while i < length(vars) {
            if vars[i] == name {
                vars[i + 1] = setto
            }
            i = i + 2
        }
        vars ~= [name, setto]
        return setto
    }
    if form[1][0] == vm.ast.index {
        arr = pass_ctfe_real(form[1][1])
        ind = pass_ctfe_real(form[1][2])
        val = pass_ctfe_real(form[2])
        if type(arr) != type([]) {
            puts("ctfe: attempt to index non-array")
            exit
        }
        if ind < 0 {
            ind = ind + length(arr)
        }
        if ind >= length(arr) {
            puts("ctfe: index out of bounds: too high")
            exit
        }
        if ind < 0 {
            puts("ctfe: index out of bounds: too low")
            exit
        }
        arr[ind] = val
    }
}

def pass_ctfe_type(form, state) {
    return type(pass_ctfe_real(form[1]))
}

def pass_ctfe_call(form, state) {
    fulldef = findvar(state[0], form[1][1])
    if fulldef == none {
        puts("cannot find function in ctfe: " ~ form[1][1])
        exit
    }
    nparams = length(fulldef[1]) - 2
    nargs = length(form) - 2
    if nparams > nargs {
        puts("expected more params")
        exit
    }
    if nparams < nargs {
        puts("expected less params")
        exit
    }
    vars = []
    i = 2
    while i < length(fulldef[1]) {
        res = pass_ctfe_real(form[i], state)
        vars ~= [fulldef[1][i][1], res]
        i = i + 1
    }
    nstate = [state[0], vars, ctfe.state.run, none]
    pass_ctfe_real(fulldef[2], nstate)
    return nstate[3]
}

def pass_ctfe_extend(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type([]) {
        puts("ctfe: attemt to extend non-array")
        exit
    }
    if type(rhs) != type([]) {
        puts("ctfe: attemt to extend array with non-array")
        exit
    }
    lhs ~= rhs
    return lhs
}

def pass_ctfe_concat(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type([]) {
        puts("ctfe: attemt to concat non-number")
        exit
    }
    if type(rhs) != type([]) {
        puts("ctfe: attemt to concat non-number")
        exit
    }
    return lhs ~ rhs
}

def pass_ctfe_add(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to add non-number")
        exit
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to add non-number")
        exit
    }
    return lhs + rhs
}

def pass_ctfe_sub(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to sub non-number")
        exit
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to sub non-number")
        exit
    }
    return lhs - rhs
}

def pass_ctfe_mul(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to mul non-number")
        exit
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to mul non-number")
        exit
    }
    return lhs * rhs
}

def pass_ctfe_div(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to div non-number")
        exit
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to div non-number")
        exit
    }
    if rhs == 0 {
        puts("ctfe: attemt to div by zero")
        exit
    }
    return lhs / rhs
}

def pass_ctfe_mod(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to mod non-number")
        exit
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to mod non-number")
        exit
    }
    if rhs == 0 {
        puts("ctfe: attemt to mod by zero")
        exit
    }
    return lhs % rhs
}

def pass_ctfe_lt(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to use < on non-number")
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to use < on non-number")
    }
    return lhs < rhs
}


def pass_ctfe_gt(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to use > on non-number")
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to use > on non-number")
    }
    return lhs > rhs
}

def pass_ctfe_lte(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to use <= on non-number")
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to use <= on non-number")
    }
    return lhs <= rhs
}

def pass_ctfe_gte(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    if type(lhs) != type(0) {
        puts("ctfe: attemt to use >= on non-number")
    }
    if type(rhs) != type(0) {
        puts("ctfe: attemt to use >= on non-number")
    }
    return lhs >= rhs
}

def pass_ctfe_eq(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    return lhs == rhs
}

def pass_ctfe_neq(form, state) {
    lhs = pass_ctfe_real(form[1], state)
    rhs = pass_ctfe_real(form[2], state)
    return lhs != rhs
}

def pass_ctfe_do(form, state) {
    cur = none
    i = 1
    while i < length(form) {
        if state[2] != ctfe.state.run {
            return cur
        }
        cur = pass_ctfe_real(form[i], state)
        i = i + 1
    }
    return cur
}

def pass_ctfe_putchar(form, state) {
    val = pass_ctfe_real(form[1], state)
    if type(val) != type(0) {
        puts("ctfe: attempt to putchar a non-number")
    }
    putchar(val)
    return none
}

def pass_ctfe_real(form, state) {
    ty = form[0]
    if ty == vm.ast.num {
        return form[1]
    }
    if ty == vm.ast.true {
        return true
    }
    if ty == vm.ast.false {
        return false
    }
    if ty == vm.ast.none {
        return none
    }
    if ty == vm.ast.str {
        return form[1]
    }
    if ty == vm.ast.ident {
        return pass_ctfe_ident(form, state)
    }
    if ty == vm.ast.index {
        return pass_ctfe_index(form, state)
    }
    if ty == vm.ast.def {
        return none
    }
    if ty == vm.ast.return {
        state[2] = ctfe.state.ret
        state[3] = pass_ctfe_real(form[1], state)
        return none
    }
    if ty == vm.ast.macro {
        return none
    }
    if ty == vm.ast.exit {
        puts("encountered `exit` in static {...}")
        puts("no output will be written and no bytecode will be run")
        exit
    }
    if ty == vm.ast.call {
        return pass_ctfe_call(form, state)
    }
    if ty == vm.ast.putchar {
        return pass_ctfe_putchar(form, state)
    }
    if ty == vm.ast.exec {
        puts("cannot `exec(...)` in static {...}")
        exit
    }
    if ty == vm.ast.length {
        return pass_ctfe_length(form, state)
    }
    if ty == vm.ast.dump {
        puts("cannot `dump(...)` in static {...}")
        exit
    }
    if ty == vm.ast.readc {
        puts("cannot `readc(...)` in static {...}")
        exit
    }
    if ty == vm.ast.read {
        puts("cannot `read(...)` in static {...}")
        exit
    }
    if ty == vm.ast.write {
        puts("cannot `write(...)` in static {...}")
        exit
    }
    if ty == vm.ast.type {
        return pass_ctfe_type(form, state)
    }
    if ty == vm.ast.array {
        return pass_ctfe_array(form, state)
    }
    if ty == vm.ast.static_array {
        return pass_ctfe_array(form, state)
    }
    if ty == vm.ast.while {
        return pass_ctfe_while(form, state)
    }
    if ty == vm.ast.foreach {
        return pass_ctfe_foreach(form, state)
    }
    if ty == vm.ast.if {
        return pass_ctfe_if(form, state)
    }
    if ty == vm.ast.do {
        return pass_ctfe_do(form, state)
    }
    if ty == vm.ast.static {
        return pass_ctfe_real(form[1], state)
    }
    if ty == "=" {
        return pass_ctfe_set(form, state)
    }
    if ty == "~=" {
        return pass_ctfe_extend(form, state)
    }
    if ty == "~" {
        return pass_ctfe_concat(form, state)
    }
    if ty == "++" {
        return pass_ctfe_concat(form, state)
    }
    if ty == "+" {
        return pass_ctfe_add(form, state)
    }
    if ty == "-" {
        return pass_ctfe_sub(form, state)
    }
    if ty == "*" {
        return pass_ctfe_mul(form, state)
    }
    if ty == "/" {
        return pass_ctfe_div(form, state)
    }
    if ty == "%" {
        return pass_ctfe_mod(form, state)
    }
    if ty == "<" {
        return pass_ctfe_lt(form, state)
    }
    if ty == ">" {
        return pass_ctfe_gt(form, state)
    }
    if ty == "<=" {
        return pass_ctfe_lte(form, state)
    }
    if ty == ">=" {
        return pass_ctfe_gte(form, state)
    }
    if ty == "==" {
        return pass_ctfe_eq(form, state)
    }
    if ty == "!=" {
        return pass_ctfe_neq(form, state)
    }
    put("exec: unknown form: ")
    println(form)
    exit
}

def pass_ctfe_const_ident(form, state) {
    val = findvar(state[0], form[1])
    if val == none {
        return form
    }
    if val[0] != vm.ast.def {
        return pass_ctfe(val)
    } else {
        return form
    }
}

def pass_ctfe_copy(form, state) {
    ret = [form[0]]
    i = 1
    while i < length(form) {
        ret ~= [pass_ctfe(form[i], state)]
        i = i + 1
    }
    return ret
}

def pass_ctfe_copy_call(form, state) {
    ret = [form[0], form[1]]
    i = 2
    while i < length(form) {
        ret ~= [pass_ctfe(form[i], state)]
        i = i + 1
    }
    return ret
}

def ctfe_real_to_ast(val) {
    if val == none {
        return [vm.ast.none]
    }
    if val == false {
        return [vm.ast.false]
    }
    if val == true {
        return [vm.ast.true]
    }
    if type(val) == type(0) {
        return [vm.ast.num, val]
    }
    if type(val) == type([]) {
        ret = [vm.ast.array]
        i = 0
        while i < length(val) {
            ret ~= ctfe_real_to_ast(val[i])
            i = i + 1
        }
        return ret
    }
    put("cannot turn value into ast: ")
    println(val)
    exit
}

def pass_ctfe(form, state) {
    ty = form[0]
    if util_ast_is_literal(ty) {
        return form
    }
    if ty == vm.ast.ident {
        return pass_ctfe_const_ident(form, state)
    }
    if ty == vm.ast.call {
        return pass_ctfe_copy_call(form, state)
    }
    if ty == vm.ast.static {
        real = pass_ctfe_real(form[1], state)
        ast = ctfe_real_to_ast(real)
        return ast
    }
    return pass_ctfe_copy(form, state)
}