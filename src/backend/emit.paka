
import("../../lang/vm/linker.paka")

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_int, ret, form[1]]]]
    return ret
}

def emit_true(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_bool, ret, 1]]]
    return ret
}

def emit_false(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_bool, ret, 0]]]
    return ret
}

def emit_binop(op, form1, form2, out) {
    r1 = emit_to(form1, out)
    r2 = emit_to(form2, out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [op, ret, r1, r2]]]
    return ret
}

def emit_binop2(op_reg, op_num, form1, form2, out) {
    r1 = emit_to(form1, out)
    if form2[0] == vm.ast.num {
        ret = reg(out)
        out[0] = out[0] ~ [[link.data, [op_num, ret, r1, form2[1]]]]
        return ret
    } else {
        r2 = emit_to(form2, out)
        ret = reg(out)
        out[0] = out[0] ~ [[link.data, [op_reg, ret, r1, r2]]]
        return ret
    }
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_putchar, r1]]]
    return 0
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_length, ret, r1]]]
    return ret
}

def emit_do(form, out) {
    ret = 0
    foreach skip(1) stmt: form {
        ret = emit_to(stmt, out)
    } 
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if length(res) == 0 {
        puts("unknown ident: " ~ form[1])
        exit
    }
    return res[0]
}

def emit_set(from, to, out) {
    if from[0] == vm.ast.ident {
        found = findvar(out[2], from[1])
        if length(found) == 0 {
            n1 = out[1]
            varreg = emit_to(to, out)
            n2 = out[1]
            if n1 == n2 {
                to = reg(out)
                out[2] = out[2] ~ [from[1], to]
                out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, to, varreg]]]
                return to
            } else {
                out[2] = out[2] ~ [from[1], varreg]
                return varreg
            }
        } else {
            from = emit_to(to, out)
            out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, found[0], from]]]
            return found[0]
        }
    }
    if from[0] == vm.ast.index {
        if from[2][0] == vm.ast.num {
            array = emit_to(from[1], out)
            varreg = emit_to(to, out)
            out[0] = out[0] ~ [[link.data, [opcode.do_index_set_int, array, from[2][1], varreg]]]
            return array
        } else {
            array = emit_to(from[1], out)
            index = emit_to(from[2], out)
            varreg = emit_to(to, out)
            out[0] = out[0] ~ [[link.data, [opcode.do_index_set, array, index, varreg]]]
            return array
        }
    }
    put("cannot set to: ")
    exit
}

def jump(out) {
    count = out[3]
    out[3] = out[3] + 1
    return count
}

def goto(jump) {
    return [link.jump, jump] 
}

def label(jump) {
    return [link.label, jump]
}

def emit_def(form, out) {
    jover = jump(out)
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    foreach skip(2) ent @i: call {
        out[2] = out[2] ~ [ent[1], i - 1]
    }
    out[1] = i - 1
    nregs = [link.data, [256]]
    out[0] = out[0] ~ [[link.data, [opcode.do_func]], goto(jover), nregs, [link.func, call[1][1]]]
    resreg = emit_to(body, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_return, resreg]]]
    nregs[1][0] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0] = out[0] ~ [label(jover)]
    return 0
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_return, rreg]]]
    return 0
}

def emit_exit(form, out) {
    out[0] = out[0] ~ [[link.data, [opcode.do_exit]]]
    return 0
}

def emit_call_static_opt(name, args, out) {
    ret = reg(out)
    if length(args) == 0 {
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call0, ret]], [link.call, name], [link.data, args]]
        return ret
    }
    if length(args) == 1 {
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call1, ret]], [link.call, name], [link.data, args]]
        return ret
    }
    if length(args) == 2 {
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call2, ret]], [link.call, name], [link.data, args]]
        return ret
    }
    if length(args) == 3 {
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call3, ret]], [link.call, name], [link.data, args]]
        return ret
    }
    out[0] = out[0] ~ [[link.data, [opcode.do_static_call, ret]], [link.call, name], [link.data, [length(args)] ~ args]]
    return ret
}

def emit_call(form, out) {
    if form[1][0] == vm.ast.ident {
        local = findvar(out[2], form[1][1])[0]
        regs = []
        foreach skip(2) arg: form {
            regs = regs ~ [emit_to(arg, out)]
        } 
        return emit_call_static_opt(form[1][1], regs, out)
    } else {
        puts("no dynamic calls yet")
        exit
    }
}

def emit_branch_alike(cond, jfalse, jtrue, out) {
    if cond[0] == vm.ast.op {
        if str.eq(cond[1], "==") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
        if str.eq(cond[1], "!=") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_not_equal_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_not_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
        if str.eq(cond[1], "<") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
        if str.eq(cond[1], ">") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
        if str.eq(cond[1], "<=") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
        if str.eq(cond[1], ">=") {
            lhs = emit_to(cond[2], out)
            if cond[3][0] == vm.ast.num {
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater_than_equal_int, lhs, cond[3][1]]], goto(jfalse), goto(jtrue)]
            } else {
                rhs = emit_to(cond[3], out)
                out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater_than_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            }
            return 0
        }
    }
    reg = emit_to(cond, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_bool, reg]], goto(jfalse), goto(jtrue)]
    return 0
}

def emit_while(form, out) {
    jredo = jump(out)
    jtrue = jump(out)
    jfalse = jump(out)
    out[0] = out[0] ~ [label(jredo)]
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [label(jtrue)]
    emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_jump]], goto(jredo)]
    out[0] = out[0] ~ [label(jfalse)]
    return 0
}

def emit_if(form, out) {
    jout = jump(out)
    jtrue = jump(out)
    jfalse = jump(out)
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [label(jtrue)]
    emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_jump]], goto(jout), label(jfalse)]
    emit_to(form[3], out)
    ## out[0] = out[0] ~ [opcode.do_jump, goto(jout)]
    out[0] = out[0] ~ [label(jout)]
    return 0
}

def emit_array(form, out) {
    regs = []
    foreach skip(1) ent: form {
        regs = regs ~ [emit_to(ent, out)]
    }
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_static_array(form, out) {
    regs = []
    foreach skip(1) ent: form {
        regs = regs ~ [emit_to(ent, out)]
    }
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_str(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_string_new, ret, length(form[1])] ~ form[1]]]
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_dump, r1, r2]]]
    return 0
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_write, r1, r2]]]
    return 0
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_read, ret, r1]]]
    return ret
}

def emit_foreach_reverse(form, out) {
    valreg = emit_to(form[2], out)
    indreg = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_length, indreg, valreg]]]
    offset = findvar(form[4][1], "skip")
    if length(offset) != 0 {
        sub = emit_to(offset[0], out)
        out[0] = out[0] ~ [[link.data, [opcode.do_sub, indreg, indreg, sub]]]
    }
    jtrue = jump(out)
    jfalse = jump(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater_int, indreg, 0]], goto(jfalse), goto(jtrue)]
    out[0] = out[0] ~ [label(jtrue)]
    foreach ent: form[1] {
        if ent[0] == vm.ast.ident {
            varreg = reg(out)
            out[2] = out[2] ~ [ent[1], varreg]
            out[0] = out[0] ~ [[link.data, [opcode.do_sub_int, indreg, indreg, 1, opcode.do_index_get, varreg, valreg, indreg]]]
        } else {
            varreg = reg(out)
            ivarreg = reg(out)
            out[2] = out[2] ~ [ent[1][1], varreg]
            out[2] = out[2] ~ [ent[2][1], ivarreg]
            out[0] = out[0] ~ [[link.data, [opcode.do_sub_int, indreg, indreg, 1, opcode.do_index_get, varreg, valreg, indreg, opcode.do_store_reg, ivarreg, indreg]]]
        }
    }
    tmpreg = emit_to(form[3], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_greater_int, indreg, 0]], goto(jfalse), goto(jtrue)]
    out[0] = out[0] ~ [label(jfalse)]
    return 0
}

def emit_foreach_forward(form, out) {
    valreg = emit_to(form[2], out)
    lenreg = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_length, lenreg, valreg]]]
    offset = findvar(form[4][1], "skip")
    indreg = reg(out)
    if length(offset) != 0 {
        xreg = emit_to(offset[0], out)
        out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, indreg, xreg]]]
    } else {
        out[0] = out[0] ~ [[link.data, [opcode.do_store_int, indreg, 0]]]
    }
    jtrue = jump(out)
    jfalse = jump(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, indreg, lenreg]], goto(jfalse), goto(jtrue)]
    out[0] = out[0] ~ [label(jtrue)]
    foreach ent: form[1] {
        if ent[0] == vm.ast.ident {
            varreg = reg(out)
            out[2] = out[2] ~ [ent[1], varreg]
            out[0] = out[0] ~ [[link.data, [opcode.do_index_get, varreg, valreg, indreg]]]
            out[0] = out[0] ~ [[link.data, [opcode.do_add_int, indreg, indreg, 1]]]
        } else {
            varreg = reg(out)
            ivarreg = reg(out)
            out[2] = out[2] ~ [ent[1][1], varreg]
            out[2] = out[2] ~ [ent[2][1], ivarreg]
            out[0] = out[0] ~ [[link.data, [opcode.do_index_get, varreg, valreg, indreg]]]
            out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, ivarreg, indreg]]]
            out[0] = out[0] ~ [[link.data, [opcode.do_add_int, indreg, indreg, 1]]]
        }
    }
    tmpreg = emit_to(form[3], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, indreg, lenreg]], goto(jfalse), goto(jtrue)]
    out[0] = out[0] ~ [label(jfalse)]
    return 0
}

def emit_foreach(form, out) {
    rev = findvar(form[4][1], "reverse")
    if length(rev) != 0 {
        if rev[0] == true {
            emit_foreach_reverse(form, out)
            return 0
        }
    }
    emit_foreach_forward(form, out)
    return 0
}


def emit_to(form, out) {
    ty = form[0]
    if ty == vm.ast.num {
        return emit_num(form, out)
    }
    if ty == vm.ast.true {
        return emit_true(form, out)
    }
    if ty == vm.ast.false {
        return emit_false(form, out)
    }
    if ty == vm.ast.index {
        return emit_binop2(opcode.do_index_get, opcode.do_index_get_int, form[1], form[2], out)
    }
    if ty == vm.ast.def {
        if length(out[0]) > 50 {
            out[4] = out[4] ~ out[0]
            out[0] = []
        }
        return emit_def(form, out)
    }
    if ty == vm.ast.return {
        return emit_return(form, out)
    }
    if ty == vm.ast.exit {
        return emit_exit(form, out)
    }
    if ty == vm.ast.call {
        return emit_call(form, out)
    }
    if ty == vm.ast.ident {
        return emit_ident(form, out)
    }
    if ty == vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if ty == vm.ast.length {
        return emit_length(form, out)
    }
    if ty == vm.ast.dump {
        return emit_dump(form, out)
    }
    if ty == vm.ast.read {
        return emit_read(form, out)
    }
    if ty == vm.ast.write {
        return emit_write(form, out)
    }
    if ty == vm.ast.static_array {
        return emit_static_array(form, out)
    }
    if ty == vm.ast.str {
        return emit_str(form, out)
    }
    if ty == vm.ast.while {
        return emit_while(form, out)
    }
    if ty == vm.ast.if {
        return emit_if(form, out)
    }
    if ty == vm.ast.do {
        return emit_do(form, out)
    }
    if ty == vm.ast.foreach {
        return emit_foreach(form, out)
    }
    if ty == vm.ast.op {
        op = form[1]
        if str.eq(op, "=") {
            return emit_set(form[2], form[3], out)
        }
        if str.eq(op, "~") {
            return emit_binop(opcode.do_static_concat, form[2], form[3], out)
        }
        if str.eq(op, "+") {
            return emit_binop2(opcode.do_add, opcode.do_add_int, form[2], form[3], out)
        }
        if str.eq(op, "-") {
            return emit_binop2(opcode.do_sub, opcode.do_sub_int, form[2], form[3], out)
        }
        if str.eq(op, "*") {
            return emit_binop2(opcode.do_mul, opcode.do_mul_int, form[2], form[3], out)
        }
        if str.eq(op, "/") {
            return emit_binop2(opcode.do_div, opcode.do_div_int, form[2], form[3], out)
        }
        if str.eq(op, "%") {
            return emit_binop2(opcode.do_mod, opcode.do_mod_int, form[2], form[3], out)
        }
        if str.eq(op, "**") {
            return emit_binop2(opcode.do_pow, opcode.do_pow_int, form[2], form[3], out)
        }
        puts("emit: form: unknown op")
        exit
    }
    puts("emit: form: unknown form")
    exit
}

def emit(form, path) {
    out = [[], 0, ["args", 0], 0, []]
    form = ctfe_run(form, path)
    form = check_all(form)
    emit_to(form, out)
    objc = out[4] ~ out[0] ~ [[link.data, [opcode.do_exit]]]
    linked = vm_link(objc)
    return linked
}