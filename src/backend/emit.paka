
import("../../lang/vm/linker.paka")

def reg(out) {
    out[1] = out[1] + 1
    return out[1]
}

def emit_num(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_int, ret, form[1]]]]
    return ret
}

def emit_binop(op, form1, form2, out) {
    r1 = emit_to(form1, out)
    r2 = emit_to(form2, out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [op, ret, r1, r2]]]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_putchar, r1]]]
    return 0
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_length, ret, r1]]]
    return ret
}

def emit_do(form, out) {
    ret = 0
    i = 1
    while i < length(form) {
        ret = emit_to(form[i], out)
        i = i + 1
    } 
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if length(res) == 0 {
        puts("unknown ident: " ~ form[1])
        exit
    }
    return res[0]
}

def emit_set(from, to, out) {
    if from[0] == vm.ast.ident {
        found = findvar(out[2], from[1])
        if length(found) == 0 {
            n1 = out[1]
            varreg = emit_to(to, out)
            n2 = out[1]
            if n1 == n2 {
                to = reg(out)
                out[2] = out[2] ~ [from[1], to]
                out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, to, varreg]]]
                return to
            } else {
                out[2] = out[2] ~ [from[1], varreg]
                return varreg
            }
        } else {
            from = emit_to(to, out)
            out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, found[0], from]]]
            return found[0]
        }
    }
    if from[0] == vm.ast.index {
        array = emit_to(from[1], out)
        index = emit_to(from[2], out)
        varreg = emit_to(to, out)
        out[0] = out[0] ~ [[link.data, [opcode.do_index_set, array, index, varreg]]]
        return array
    }
    put("cannot set to: ")
    exit
}

def jump(out) {
    count = out[3]
    out[3] = out[3] + 1
    return count
}

def goto(jump) {
    return [link.jump, jump] 
}

def label(jump) {
    return [link.label, jump]
}

def emit_def(form, out) {
    jover = jump(out)
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    out[2] = []
    i = 2
    while i < length(call) {
        out[2] = out[2] ~ [call[i][1], i - 1]
        i = i + 1
    }
    out[1] = i - 1
    nregs = [link.data, [256]]
    out[0] = out[0] ~ [[link.data, [opcode.do_func]], goto(jover), nregs, [link.func, call[1][1]]]
    resreg = emit_to(body, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_return, resreg]]]
    nregs[1][0] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[0] = out[0] ~ [label(jover)]
    return 0
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_return, rreg]]]
    return 0
}

def emit_exit(form, out) {
    out[0] = out[0] ~ [[link.data, [opcode.do_exit]]]
    return 0
}

def emit_call(form, out) {
    if form[1][0] == vm.ast.ident {
        local = findvar(out[2], form[1][1])[0]
        args = []
        i = 2
        while i < length(form) {
            args = args ~ [emit_to(form[i], out)]
            i = i + 1
        } 
        ret = reg(out)
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call, ret]], [link.call, form[1][1]], [link.data, [length(args)] ~ args]]
        return ret
    } else {
        puts("no dynamic calls yet")
        exit
    }
}

def emit_branch_alike(cond, jfalse, jtrue, out) {
    if cond[0] == vm.ast.op {
        if str.eq(cond[1], "==") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], "!=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal, lhs, rhs]], goto(jtrue), goto(jfalse)]
            return 0
        }
        if str.eq(cond[1], "<") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, lhs, rhs]], goto(jfalse), goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], ">") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, rhs, lhs]], goto(jfalse), goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], "<=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal, lhs, rhs]], goto(jfalse), goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], ">=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal, rhs, lhs]], goto(jfalse), goto(jtrue)]
            return 0
        }
    }
    reg = emit_to(cond, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_bool, reg]], goto(jfalse), goto(jtrue)]
    return 0
}

def emit_while(form, out) {
    jredo = jump(out)
    jtrue = jump(out)
    jfalse = jump(out)
    out[0] = out[0] ~ [label(jredo)]
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [label(jtrue)]
    emit_to(form[2], out)
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [label(jfalse)]
    return 0
}

def emit_if(form, out) {
    jout = jump(out)
    jtrue = jump(out)
    jfalse = jump(out)
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [label(jtrue)]
    emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_jump]], goto(jout), label(jfalse)]
    emit_to(form[3], out)
    out[0] = out[0] ~ [label(jout)]
    return 0
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_static_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_str(form, out) {
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_string_new, ret, length(form[1])] ~ form[1]]]
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_dump, r1, r2]]]
    return 0
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_write, r1, r2]]]
    return 0
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_read, ret, r1]]]
    return ret
}

def emit_to(form, out) {
    ty = form[0]
    if ty == vm.ast.num {
        return emit_num(form, out)
    }
    if ty == vm.ast.index {
        return emit_binop(opcode.do_index_get, form[1], form[2], out)
    }
    if ty == vm.ast.def {
        if length(out[0]) > 50 {
            out[4] = out[4] ~ out[0]
            out[0] = []
        }
        return emit_def(form, out)
    }
    if ty == vm.ast.return {
        return emit_return(form, out)
    }
    if ty == vm.ast.exit {
        return emit_exit(form, out)
    }
    if ty == vm.ast.call {
        return emit_call(form, out)
    }
    if ty == vm.ast.ident {
        return emit_ident(form, out)
    }
    if ty == vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if ty == vm.ast.length {
        return emit_length(form, out)
    }
    if ty == vm.ast.dump {
        return emit_dump(form, out)
    }
    if ty == vm.ast.read {
        return emit_read(form, out)
    }
    if ty == vm.ast.write {
        return emit_write(form, out)
    }
    if ty == vm.ast.static_array {
        return emit_static_array(form, out)
    }
    if ty == vm.ast.str {
        return emit_str(form, out)
    }
    if ty == vm.ast.while {
        return emit_while(form, out)
    }
    if ty == vm.ast.if {
        return emit_if(form, out)
    }
    if ty == vm.ast.do {
        return emit_do(form, out)
    }
    if ty == vm.ast.op {
        op = form[1]
        if str.eq(op, "=") {
            return emit_set(form[2], form[3], out)
        }
        if str.eq(op, "~") {
            return emit_binop(opcode.do_static_concat, form[2], form[3], out)
        }
        if str.eq(op, "+") {
            return emit_binop(opcode.do_add, form[2], form[3], out)
        }
        if str.eq(op, "-") {
            return emit_binop(opcode.do_sub, form[2], form[3], out)
        }
        if str.eq(op, "*") {
            return emit_binop(opcode.do_mul, form[2], form[3], out)
        }
        if str.eq(op, "/") {
            return emit_binop(opcode.do_div, form[2], form[3], out)
        }
        if str.eq(op, "%") {
            return emit_binop(opcode.do_mod, form[2], form[3], out)
        }
        puts("emit: form: unknown op")
        exit
    }
    puts("emit: form: unknown form")
    exit
}

def emit(form, path) {
    out = [[], 0, ["args", 0], 0, []]
    form = ctfe_run(form, path)
    form = check_all(form)
    emit_to(form, out)
    objc = out[4] ~ out[0] ~ [[link.data, [opcode.do_exit]]]
    linked = vm_link(objc)
    return linked
}