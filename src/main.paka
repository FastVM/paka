def id(v) v
def empty() []
def push(x, y) __cat x [y]

## io

def put(str) {
    __let i 0
    while __lt i length str {
        putchar(__get str i)
        __let i __add i 1
    }
}

def puts(str) {
    put(str)
    putchar(10)
}

def putn_gte0(n) {
    if __gte n 10 {
        __let lowest __mod n 10
        putn_gte0(__div __sub n lowest 10)
        putchar(__add lowest 48)
    } else {
        putchar(__add 48 __mod n 10)
    }
}

def putn(n) {
    if __lt n 0 {
        put("-")
        putn_gte0(__sub 0 n)
    } else {
        putn_gte0(n)
    }
}

## strings

def char_between(chr, pair) {
    if __lte __get pair 0 chr {
        if __lte chr __get pair 1 {
            return 1
        }
    }
    return 0
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return 1
    } else {
        return 0
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return 1
    }
    if char_between(chr, "AZ") {
        return 1
    }
    return 0
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return 1
    }
    if __eq chr '.' {
        return 1
    }
    if __eq chr '_' {
        return 1
    }
    return 0
}

def char_id(chr) {
    if char_id0(chr) {
        return 1
    }
    if char_isdigit(chr) {
        return 1
    }
    return 0
}

def str_starts_with(src, items) {
    if __gt length items length src {
        return 0
    }
    __let i 0
    while __lt i length items {
        if __neq __get items i __get src i {
            return 0
        }
        __let i __add i 1
    }
    return 1
}

def str.eq(sa, sb) {
    __let len length sa
    if __neq length sa length sb {
        return 0
    }
    __let i 0
    while __lt i len {
        if __neq __get sa i __get sb i {
            return 0
        }
        __let i __add i 1
    }
    return 1
}

## char streams

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if __lt __get src 1 length (__get src 0) {
        return __get __get src 0 __get src 1
    } else {
        return 0
    }
}

def stream_skip1(src) {
    if __lt __get src 1 length (__get src 0) {
        __set src 1 __add __get src 1 1
    }
}

def stream_skip(src, n) {
    __let i 0
    while __lt i n {
        stream_skip1(src)
        __let i __add i 1
    }
}

def stream_read(src) {
    __let ret stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if __gt __add length items __get src 1 length __get src 0 {
        return 0
    }
    __let i 0
    while __lt i length items {
        if __neq __get items i __get __get src 0 __add __get src 1 i {
            return 0
        }
        __let i __add i 1
    }
    return 1
}

## linker

macro link {
    __let data 0
    __let jump 1
    __let label 2
    __let call 3
    __let func 4
}

def vm_link(bc) {
    __let nops 0
    __let func_locs empty
    __let sized0 empty
    __let sized1 empty
    __let labels empty
    __let i 0
    while __lt i length bc {
        __let cur __get bc  i
        if __eq __get cur 0 link.func {
            __let func_locs __cat func_locs [__get cur 1, nops]
        }
        if __eq __get cur 0 link.label {
            __let labels __cat labels [__get cur 1, nops]
        }
        if __eq __get cur 0 link.call {
            __let sized0 push sized0 cur
            __let nops __add nops 1
        }
        if __eq __get cur 0 link.jump {
            __let sized0 push sized0 cur
            __let nops __add nops 1
        }
        if __eq __get cur 0 link.data {
            __let sized0 push sized0 cur
            __let nops __add nops length __get cur 1
        }
        if __gte length sized0 50 {
            __let sized1 __cat sized1 sized0
            __let sized0 empty
        }
        __let i __add i 1
    }
    __let sized __cat sized1 sized0
    __let ops0 empty
    __let ops1 empty
    __let ops2 empty
    __let ops3 empty
    __let ops4 empty
    __let i 0
    while __lt i length sized {
        __let op __get sized i
        __let linktype __get op 0
        if __eq linktype link.data {
            __let ops0 __cat ops0 __get op 1
            if __gte length ops0 30 {
                __let ops1 __cat ops1 ops0
                __let ops0 empty
                if __gt length ops1 90 {
                    __let ops2 __cat ops2 ops1
                    __let ops1 empty
                    if __gt length ops2 300 {
                        __let ops3 __cat ops3 ops2
                        __let ops2 empty
                    }
                }
            }
        }
        if __eq linktype link.jump {
            __let found findvar.ikey(labels, __get op 1)
            if __eq length found 0 {
                puts("cannot jump to undefined label")
                exit
            }
            __let ops0 __cat ops0 found
        }
        if __eq linktype link.call {
            __let func findvar(func_locs, __get op 1)
            if __eq length func 0 {
                put("link error: undefined: ")
                puts(__get op 1)
                exit
            }
            __let ops0 __cat ops0 [__get func 0]
        }
        __let i __add i 1
    }
    return __cat ops3 __cat ops2 __cat ops1 ops0
}

## opcodes

macro vm {
    ast.num
    ast.index
    ast.def
    ast.return
    ast.enum
    ast.when
    ast.exit
    ast.call
    ast.ident
    ast.length
    ast.import
    ast.dump
    ast.read
    ast.write
    ast.str
    ast.while
    ast.if
    ast.do
    ast.attrs
    ast.putchar
    ast.value_key
    ast.static_array
    ast.op
}

macro token {
    open.paren
    open.square
    open.curly
    close.paren
    close.square
    close.curly
    colon
    comma
    keyword.while
    keyword.if
    keyword.else
    keyword.def
    keyword.return
    keyword.macro
    keyword.exit
    op
    str
    num
    ident
}

macro opcode {
    __let do_exit 0
    __let do_store_reg 1
    __let do_branch_bool 2
    __let do_store_int 3
    __let do_jump 4
    __let do_func 5
    __let do_add 6
    __let do_sub 7
    __let do_mul 8
    __let do_div 9
    __let do_mod 10
    __let do_branch_less_than_equal 11
    __let do_static_call 12
    __let do_return 13
    __let do_putchar 14
    __let do_string_new 15
    __let do_length 16
    __let do_index_get 17
    __let do_index_set 18
    __let do_dump 19
    __let do_read 20
    __let do_write 21
    __let do_static_array_new 22
    __let do_static_concat 23
    __let do_branch_equal 24
    __let do_branch_less 25
}

## find variables

def findvar(vars, name) {
    __let i 0
    while __lt i length vars {
        __let k __get vars i
        __let i __add i 1
        __let v __get vars i
        __let i __add i 1
        if str.eq(k, name) {
            return [v]
        }
    }
    return empty
}

def findvar.ikey(vars, name) {
    __let i 0
    while __lt i length vars {
        __let k __get vars i
        __let i __add i 1
        __let v __get vars i
        __let i __add i 1
        if __eq k name {
            return [v]
        }
    }
    return empty
}

## macro resolver

def pass_macro_resolve_copy(form, state) {
    __let ret [__get form 0]
    __let i 1
    while __lt i length form {
        __let ret __cat ret [pass_macro_resolve(__get form i, state)]
        __let i __add i 1
    }
    return ret
}

def pass_macro_resolve_enum(form, state) {
    __let name __get __get form 1 1
    __let idents empty
    __let where 1
    while __lt where length __get form 2 {
        __let ok 0
        if __eq __get __get __get form 2 where 0 vm.ast.ident {
            __let fullname __cat __get __get form 1 1 __cat "." __get __get __get form 2 where 1
            __let ast [vm.ast.num, where]
            __set state 0 __cat __get state 0 [fullname, ast]
            __let ok 1
        }
        if __eq __get __get __get form 2 where 0 vm.ast.op {
            if str.eq(__get __get __get form 2 where 1, "=") {
                __let setto __get __get __get form 2 where 2
                __let val __get __get __get form 2 where 3
                if __neq __get setto 0 vm.ast.ident {
                    puts("enum macro given bad value on left hand size of `=`")
                    exit
                }
                __let fullname __cat __get __get form 1 1 __cat "." __get setto 1
                __set state 0 __cat __get state 0 [fullname, val]
                __let ok 1
            }
        }
        if __eq ok 0 {
            puts("that is not valid in a macro")
            exit
        }
        __let where __add where 1
    }
    return [vm.ast.do]
}
 
def pass_macro_resolve(form, state) {
    __let ty __get form 0
    if __eq ty vm.ast.num {
        return form
    }
    if __eq ty vm.ast.str {
        return form
    }
    if __eq ty vm.ast.attrs {
        return form
    }
    if __eq ty vm.ast.ident {
        __let val findvar(__get state 0, __get form 1)
        if __neq length val 0 {
            return __get val 0
        }
        return form
    }
    if __eq ty vm.ast.op {
        return [ty, __get form 1, pass_macro_resolve(__get form 2, state), pass_macro_resolve(__get form 3, state)]
    }
    if __eq ty vm.ast.enum {
        return pass_macro_resolve_enum(form, state)
    }
    if __eq ty vm.ast.def {
        return pass_macro_resolve_copy(form, state)
    }
    return pass_macro_resolve_copy(form, state)
}

## emit

def put_reg(out) {
    __set out 1 __add __get out 1 1
    return __get out 1
}

def emit_num(form, out) {
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_int, ret, __get form 1])])]
    return ret
}

def emit_binop(op, form1, form2, out) {
    __let r1 emit_to(form1, out)
    __let r2 emit_to(form2, out)
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([op, ret, r1, r2])])]
    return ret
}

def emit_putchar(form, out) {
    __let r1 emit_to(__get form 1, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_putchar, r1])])]
    return 0
}

def emit_length(form, out) {
    __let r1 emit_to(__get form 1, out)
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_length, ret, r1])])]
    return ret
}

def emit_do(form, out) {
    __let ret 0
    __let i 1
    while __lt i length form {
        __let ret emit_to(__get form i, out)
        __let i __add i 1
    } 
    return ret
}

def emit_ident(form, out) {
    __let res findvar(__get out 2, __get form 1)
    if __eq length res 0 {
        puts(__cat "unknown ident: " __get form 1)
        exit
    }
    return __get res 0
}

def emit_set(from, to, out) {
    if __eq __get from 0 vm.ast.ident {
        __let found findvar(__get out 2, __get from 1)
        if __eq length found 0 {
            __let varreg emit_to(to, out)
            __let to put_reg(out)
            __set out 2 __cat __get out 2 [__get from 1, to]
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, to, varreg])])]
            return to
        } else {
            __let from emit_to(to, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, __get found 0, from])])]
            return __get found 0
        }
    }
    if __eq __get from 0 vm.ast.index {
        __let array emit_to(__get from 1, out)
        __let index emit_to(__get from 2, out)
        __let varreg emit_to(to, out)
        __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_index_set, array, index, varreg])])]
        return array
    }
    put("cannot __set to: ")
    putn(__get from 0)
    putchar(10)
    exit
}

def put_jump(out) {
    __let count __get out 3
    __set out 3 __add __get out 3 1
    return count
}

def put_goto(jump) {
    return [link.jump, jump] 
}

def put_label(jump) {
    return [link.label, jump]
}

def emit_def(form, out) {
    __let jover put_jump(out)
    __let call __get form 1
    __let body __get form 2
    __let tmp1 __get out 1
    __let tmp2 __get out 2
    __set out 2 empty
    __let i 2
    while __lt i length call {
        __set out 2 __cat __get out 2 [__get __get call i 1, __sub i 1]
        __let i __add i 1
    }
    __set out 1 __sub i 1
    __let nregs [link.data, [256]]
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_func])]), put_goto(jover), nregs, id([link.func, __get __get call 1 1])]
    __let resreg emit_to(body, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_return, resreg])])]
    __set __get nregs 1 0 __get out 1
    __set out 1 tmp1
    __set out 2 tmp2
    __set out 0 __cat __get out 0 [put_label(jover)]
    return 0
}

def emit_return(form, out) {
    __let rreg emit_to(__get form 1, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_return, rreg])])]
    return 0
}

def emit_exit(form, out) {
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_exit])])]
    return 0
}

def emit_call(form, out) {
    if __eq __get __get form 1 0 vm.ast.ident {
        __let args empty
        __let i 2
        while __lt i length form {
            __let args push args emit_to(__get form i, out)
            __let i __add i 1
        } 
        __let ret put_reg(out)
        __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_static_call, ret])]), id([link.call, __get __get form 1 1]), id([link.data, __cat id([length args]) args])]
        return ret
    } else {
        puts("no dynamic calls yet")
        exit
    }
}

def emit_branch_alike(cond, jfalse, jtrue, out) {
    if __eq __get cond 0 vm.ast.op {
        __let first __get __get cond 1 0
        if str.eq(__get cond 1, ">") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less, rhs, lhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "<=") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less_than_equal, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "==") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_equal, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "!=") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_equal, lhs, rhs])]),put_goto(jtrue), put_goto(jfalse)]
            return 0
        }
        if str.eq(__get cond 1, "<") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, ">=") {
            __let lhs emit_to(__get cond 2, out)
            __let rhs emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less_than_equal, rhs, lhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
    }
    __let reg emit_to(cond, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_bool, reg])]),put_goto(jfalse), put_goto(jtrue)]
    return 0
}

def emit_while(form, out) {
    __let jredo put_jump(out)
    __let jtrue put_jump(out)
    __let jfalse put_jump(out)
    __set out 0 __cat __get out 0 [put_label(jredo)]
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    __set out 0 __cat __get out 0 [put_label(jtrue)]
    emit_to(__get form 2, out)
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    __set out 0 __cat __get out 0 [put_label(jfalse)]
    return 0
}

def emit_if(form, out) {
    __let jout put_jump(out)
    __let jtrue put_jump(out)
    __let jfalse put_jump(out)
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    __let rret put_reg(out)
    __set out 0 __cat __get out 0 [put_label(jtrue)]
    __let rtrue emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, rret, rtrue, opcode.do_jump])]),put_goto(jout), put_label(jfalse)]
    __let rfalse emit_to(__get form 3, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, rret, rfalse])])]
    __set out 0 __cat __get out 0 [put_label(jout)]
    return rret
}

def emit_array(form, out) {
    __let regs empty
    __let i 1
    while __lt i length form {
        __let regs __cat regs [emit_to(__get form i, out)]
        __let i __add i 1
    }
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_static_array_new, ret, length regs]) regs])]
    return ret
}

def emit_static_array(form, out) {
    __let regs empty
    __let i 1
    while __lt i length form {
        __let regs __cat regs [emit_to(__get form i, out)]
        __let i __add i 1
    }
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_static_array_new, ret, length regs]) regs])]
    return ret
}

def emit_str(form, out) {
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_string_new, ret, length __get form 1]) __get form 1])]
    return ret
}

def emit_dump(form, out) {
    __let r1 emit_to(__get form 1, out)
    __let r2 emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_dump, r1, r2])])]
    return 0
}

def emit_write(form, out) {
    __let r1 emit_to(__get form 1, out)
    __let r2 emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_write, r1, r2])])]
    return 0
}

def emit_read(form, out) {
    __let r1 emit_to(__get form 1, out)
    __let ret put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_read, ret, r1])])]
    return ret
}

def emit_to(form, out) {
    __let ty __get form 0
    if __eq ty vm.ast.num {
        return emit_num(form, out)
    }
    if __eq ty vm.ast.index {
        return emit_binop(opcode.do_index_get, __get form 1, __get form 2, out)
    }
    if __eq ty vm.ast.def {
        if __gt length __get out 0 50 {
            __set out 4 __cat __get out 4 __get out 0
            __set out 0 empty
        }
        return emit_def(form, out)
    }
    if __eq ty vm.ast.return {
        return emit_return(form, out)
    }
    if __eq ty vm.ast.exit {
        return emit_exit(form, out)
    }
    if __eq ty vm.ast.call {
        return emit_call(form, out)
    }
    if __eq ty vm.ast.ident {
        return emit_ident(form, out)
    }
    if __eq ty vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if __eq ty vm.ast.length {
        return emit_length(form, out)
    }
    if __eq ty vm.ast.dump {
        return emit_dump(form, out)
    }
    if __eq ty vm.ast.read {
        return emit_read(form, out)
    }
    if __eq ty vm.ast.write {
        return emit_write(form, out)
    }
    if __eq ty vm.ast.static_array {
        return emit_static_array(form, out)
    }
    if __eq ty vm.ast.str {
        return emit_str(form, out)
    }
    if __eq ty vm.ast.while {
        return emit_while(form, out)
    }
    if __eq ty vm.ast.if {
        return emit_if(form, out)
    }
    if __eq ty vm.ast.do {
        return emit_do(form, out)
    }
    if __eq ty vm.ast.op {
        __let op __get __get form 1 0
        if __eq op '=' {
            return emit_set(__get form 2, __get form 3, out)
        }
        if __eq op '~' {
            return emit_binop(opcode.do_static_concat, __get form 2, __get form 3, out)
        }
        if __eq op '+' {
            return emit_binop(opcode.do_add, __get form 2, __get form 3, out)
        }
        if __eq op '-' {
            return emit_binop(opcode.do_sub, __get form 2, __get form 3, out)
        }
        if __eq op '*' {
            return emit_binop(opcode.do_mul, __get form 2, __get form 3, out)
        }
        if __eq op '/' {
            return emit_binop(opcode.do_div, __get form 2, __get form 3, out)
        }
        if __eq op '%' {
            return emit_binop(opcode.do_mod, __get form 2, __get form 3, out)
        }
        puts("emit: form: unknown op")
        exit
    }
    puts("emit: form: unknown form")
    exit
}

def emit(form, path) {
    __let out [empty, 0, id(["args", 0]), 0, empty, empty]
    __let form pass_macro_resolve(form, [empty])
    emit_to(form, out)
    __let objc __cat __get out 4 __cat __get out 0 [id([link.data, id([opcode.do_exit])])]
    __let linked vm_link(objc)
    return linked
}

## paka

def paka_tokenize_stream1(bsrc) {
    __let first stream_peek(bsrc)
    if __eq first ' ' {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc)
    }
    if __eq first 10 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc)
    }
    if __eq first 13 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc)
    }
    if __eq first '#' {
        stream_skip1(bsrc)
        while 1 {
            __let cur stream_read(bsrc)
            if __eq cur 10 {
                return paka_tokenize_stream1(bsrc)
            }
            if __eq cur 13 {
                return paka_tokenize_stream1(bsrc)
            }
        }
    }
    if __eq first '(' {
        stream_skip1(bsrc)
        return [token.open.paren]
    }
    if __eq first ')' {
        stream_skip1(bsrc)
        return [token.close.paren]
    }
    if __eq first '{' {
        stream_skip1(bsrc)
        return [token.open.curly]
    }
    if __eq first '}' {
        stream_skip1(bsrc)
        return [token.close.curly]
    }
    if __eq first '[' {
        stream_skip1(bsrc)
        return [token.open.square]
    }
    if __eq first ']' {
        stream_skip1(bsrc)
        return [token.close.square]
    }
    if __eq first ',' {
        stream_skip1(bsrc)
        return [token.comma]
    }
    if __eq first ''' {
        stream_skip1(bsrc)
        __let cur stream_read(bsrc)
        if __eq cur '\\' {
            __let cur stream_read(bsrc)
            if __neq stream_read(bsrc) ''' {
                puts("unterminated char literal")
                exit
            }
            if __eq cur 'n' {
                return [token.num, 10]
            } 
            if __eq cur 'r' {
                return [token.num, 13]
            } 
            if __eq cur 34 {
                return [token.num, cur]
            }
            if __eq cur '\\' {
                return [token.num, cur]
            }
        } else {
            if __neq stream_read(bsrc) ''' {
                puts("unterminated char literal")
                exit
            }
            return [token.num, cur]
        }
    }
    if __eq first 34 {
        stream_skip1(bsrc)
        __let ret empty
        while 1 {
            __let cur stream_read(bsrc)
            if __eq cur 0 {
                puts("eof in str")
                exit
            }
            if __eq cur 34 {
                return [token.str, ret]
            }
            if __eq cur '\\' {
                __let cur stream_read(bsrc)
                if __eq cur 'n' {
                    __let ret push ret 10
                } 
                if __eq cur 34 {
                    __let ret __cat ret "\""
                }
                if __eq cur '\\' {
                    __let ret __cat ret "\\"
                }
            } else {
                __let ret push ret cur
            }
        }
    }
    if char_isdigit(first) {
        __let n 0
        while char_isdigit(stream_peek(bsrc)) {
            __let n __add __mul n 10 __sub stream_read(bsrc) '0'
        }
        return [token.num, n]
    }
    if char_id0(first) {
        __let xsrc empty
        while 1 {
            if char_id(stream_peek(bsrc)) {
                __let xsrc push xsrc stream_read(bsrc)
            } else {
                __let n0 __get xsrc 0
                if __eq n0 'w' {
                    if str.eq(xsrc, "while") {
                        return [token.keyword.while]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'i' {
                    if str.eq(xsrc, "if") {
                        return [token.keyword.if]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'e' {
                    if str.eq(xsrc, "else") {
                        return [token.keyword.else]
                    }
                    if str.eq(xsrc, "exit") {
                        return [token.keyword.exit]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'd' {
                    if str.eq(xsrc, "def") {
                        return [token.keyword.def]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'r' {
                    if str.eq(xsrc, "return") {
                        return [token.keyword.return]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'm' {
                    if str.eq(xsrc, "macro") {
                        return [token.keyword.macro]
                    }
                    return [token.ident, xsrc]
                }
                return [token.ident, xsrc]
            }
        }
    }
    if __eq first 0 {
        return empty
    }
    put("bad char: code ")
    putn(first)
    putchar(10)
    exit
}

def token_stream_new(src) {
    return [[src, 0], empty]
}

def token_stream_read(tokens) {
    __let ret token_stream_peek(tokens)
    token_stream_skip1(tokens)
    return ret
}

def token_stream_peek(tokens) {
    if __eq length __get tokens 1 0 {
        __set tokens 1 paka_tokenize_stream1(__get tokens 0)
    }
    return __get tokens 1
}

def token_stream_skip1(tokens) {
    if __eq length __get tokens 1 0 {
        paka_tokenize_stream1(__get tokens 0)
    }
    __set tokens 1 empty
}

def paka_skip_comma(tokens) {
    __let first token_stream_peek(tokens)
    if __eq __get first 0 token.comma {
        token_stream_skip1(tokens)
    }
}

def paka_read_scall(tokens, nargs, args, state) {
    __let target __add nargs length args
    __let got token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            __let cur token_stream_peek(tokens)
            if __eq length cur 0 {
                puts("error eof arg")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                if __neq length args target {
                    puts("error: argc")
                    exit
                }
                return paka_read_post(tokens, args, state)
            }
            __let arg paka_read_expr_base(tokens, state)
            __let args push args arg
            paka_skip_comma(tokens)
        }
    }
    while __lt length args target {
        __let cur token_stream_peek(tokens)
        if __eq length cur 0 {
            puts("error eof arg")
        }
        __let arg paka_read_expr_base(tokens, state)
        __let args push args arg
        paka_skip_comma(tokens)
    }
    return paka_read_post(tokens, args, state)
}

def paka_read_call(tokens, args, state) {
    __let got token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            __let cur token_stream_peek(tokens)
            if __eq length cur 0 {
                puts("error 1")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                return paka_read_post(tokens, args, state)
            }
            __let arg paka_read_expr_base(tokens, state)
            __let args push args arg
            paka_skip_comma(tokens)
        }
    }
    puts("error: wanted `(`")
    exit
}

def paka_read_post(tokens, last, state) {
    __let first token_stream_peek(tokens)
    if __eq length first 0 {
        return last
    }
    if __eq __get first 0 token.open.paren {
        if __neq __get last 0 vm.ast.ident {
            put("cannot call anything but idents: ")
            putn(__get last 0)
            putchar(10)
            exit
        }
        __let found findvar(__get state 1, __get last 1)
        if __eq length found 0 {
            __let args [vm.ast.call, last] 
            return paka_read_call(tokens, args, state)
        } else {
            __let args [vm.ast.call, last] 
            return paka_read_scall(tokens, __get found 0, args, state)
        }
    }
    if __eq __get last 0 vm.ast.ident {
        __let found findvar(__get state 1, __get last 1)
        if __eq length found 1 {
            __let args [vm.ast.call, last] 
            return paka_read_scall(tokens, __get found 0, args, state)
        }
    }
    return last
}

def paka_read_single(tokens, state) {
    __let first token_stream_peek(tokens)
    if __eq length first 0 {
        return 0
    }
    if __eq __get first 0 token.open.square {
        token_stream_skip1(tokens)
        __let args [vm.ast.static_array]
        while 1 {
            __let cur token_stream_peek(tokens)
            if __eq __get cur 0 token.close.square {
                token_stream_skip1(tokens)
                return args
            }
            __let expr paka_read_expr_base(tokens, state)
            __let args push args expr
            paka_skip_comma(tokens)
        } 
    }
    if __eq __get first 0 token.open.paren {
        token_stream_skip1(tokens)
        __let ret paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    if __eq __get first 0 token.num {
        token_stream_skip1(tokens)
        return [vm.ast.num, __get first 1]
    }
    if __eq __get first 0 token.str {
        token_stream_skip1(tokens)
        return [vm.ast.str, __get first 1]
    }
    if __eq __get first 0 token.ident {
        token_stream_skip1(tokens)
        if str.eq(__get first 1, "putchar") {
            return paka_read_scall(tokens, 1, [vm.ast.putchar], state)
        } 
        if str.eq(__get first 1, "length") {
            return paka_read_scall(tokens, 1, [vm.ast.length], state)
        }
        if str.eq(__get first 1, "dump") {
            return paka_read_scall(tokens, 2, [vm.ast.dump], state)
        }
        if str.eq(__get first 1, "write") {
            return paka_read_scall(tokens, 2, [vm.ast.write], state)
        }
        if str.eq(__get first 1, "read") {
            return paka_read_scall(tokens, 1, [vm.ast.read], state)
        }
        if __eq __get __get first 1 0 '_' {
            if str.eq(__get first 1, "__get") {
                return paka_read_scall(tokens, 2, [vm.ast.index], state)
            }
            if str.eq(__get first 1, "__set") {
                __let args paka_read_scall(tokens, 3, empty, state)
                return [vm.ast.op, "=", [vm.ast.index, __get args 0, __get args 1], __get args 2]
            }
            if str.eq(__get first 1, "__add") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "+"], state)
            }
            if str.eq(__get first 1, "__sub") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "-"], state)
            }
            if str.eq(__get first 1, "__mul") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "*"], state)
            }
            if str.eq(__get first 1, "__div") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "/"], state)
            }
            if str.eq(__get first 1, "__mod") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "%"], state)
            }
            if str.eq(__get first 1, "__cat") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "~"], state)
            }
            if str.eq(__get first 1, "__lt") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "<"], state)
            }
            if str.eq(__get first 1, "__gt") {
                return paka_read_scall(tokens, 2, [vm.ast.op, ">"], state)
            }
            if str.eq(__get first 1, "__lte") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "<="], state)
            }
            if str.eq(__get first 1, "__gte") {
                return paka_read_scall(tokens, 2, [vm.ast.op, ">="], state)
            }
            if str.eq(__get first 1, "__eq") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "=="], state)
            }
            if str.eq(__get first 1, "__neq") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "!="], state)
            }
            if str.eq(__get first 1, "__let") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "="], state)
            }
        if str.eq(__get first 1, "putchar") {
            return paka_read_scall(tokens, 1, [vm.ast.putchar], state)
        } 
        if str.eq(__get first 1, "length") {
            return paka_read_scall(tokens, 1, [vm.ast.length], state)
        }
        if str.eq(__get first 1, "dump") {
            return paka_read_scall(tokens, 2, [vm.ast.dump], state)
        }
        if str.eq(__get first 1, "write") {
            return paka_read_scall(tokens, 2, [vm.ast.write], state)
        }
        if str.eq(__get first 1, "read") {
            return paka_read_scall(tokens, 1, [vm.ast.read], state)
        }
        }
        return [vm.ast.ident, __get first 1]
    }
    if __eq __get first 0 token.keyword.if {
        token_stream_skip1(tokens)
        __let expr paka_read_expr_base(tokens, state)
        __let block1 paka_read_block(tokens, state)
        __let block2 [vm.ast.do]
        __let first token_stream_peek(tokens)
        if __eq __get first 0 token.keyword.else {
            token_stream_skip1(tokens)
            __let block2 paka_read_block(tokens, state)
        }
        return [vm.ast.if, expr, block1, block2]
    }
    put("error: unexpected token#")
    putn(__get first 0)
    puts(".")
    exit
}

def parse_is_not_in(op, some) {
    __let i 0
    while __lt i length some {
        if str.eq(op, __get some i) {
            return 0
        }
        __let i __add i 1
    }
    return 1
}

def paka_read_expr_base(tokens, state) {
    return paka_read_post(tokens, paka_read_single(tokens, state), state)
}

def paka_read_stmt(tokens, state) {
    __let first token_stream_peek(tokens)
    if __eq __get first 0 token.keyword.while {
        token_stream_skip1(tokens)
        __let expr paka_read_expr_base(tokens, state)
        __let block paka_read_block(tokens, state)
        return [vm.ast.while, expr, block]
    }
    if __eq __get first 0 token.keyword.def {
        token_stream_skip1(tokens)
        __let expr paka_read_expr_base(tokens, state)
        __let block paka_read_block(tokens, state)
        return [vm.ast.def, expr, block]
    }
    if __eq __get first 0 token.keyword.return {
        token_stream_skip1(tokens)
        __let expr paka_read_expr_base(tokens, state)
        return [vm.ast.return, expr]
    }
    if __eq __get first 0 token.keyword.macro {
        token_stream_skip1(tokens)
        __let name token_stream_read(tokens)
        __let first token_stream_peek(tokens)
        __let block paka_read_block(tokens, state)
        return [vm.ast.enum, id([vm.ast.ident, __get name 1]), block]
    }
    if __eq __get first 0 token.keyword.exit {
        token_stream_skip1(tokens)
        return [vm.ast.exit]
    }
    __let ret paka_read_expr_base(tokens, state)
    return ret
}

def paka_read_block_body(tokens, state) {
    __let ret [vm.ast.do]
    while 1 {
        __let first token_stream_peek(tokens)
        if __eq length first 0 {
            return ret
        }
        if __eq __get first 0 token.close.curly {
            return ret
        }
        __let stmt paka_read_stmt(tokens, state)
        __let ret push ret stmt
    }
}

def paka_read_block(tokens, state) {
    __let first token_stream_peek(tokens)
    if __eq __get first 0 token.open.curly {
        token_stream_skip1(tokens)
        __let ret paka_read_block_body(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    return [vm.ast.do, paka_read_stmt(tokens, state)]
}

def paka_read_nargs(tokens, name, state) {
    __let got token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        __let n 0
        while 1 {
            __let cur token_stream_peek(tokens)
            if __eq length cur 0 {
                puts("error: need `)` after args to def")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                return n
            }
            paka_read_expr_base(tokens, state)
            __let n __add n 1
            paka_skip_comma(tokens)
        }
    } else {
        __let n 0
        while 1 {
            __let cur token_stream_peek(tokens)
            if __eq length cur 0 {
                puts("error: need `:` after def")
            }
            if __eq __get cur 0 token.op {
                if str.eq(__get cur 1, ":") {
                    token_stream_skip1(tokens)
                    return n
                }
            }
            paka_read_expr_base(tokens, state)
            __let n __add n 1
            paka_skip_comma(tokens)
        }
    }
}

def paka_build_defs(tokens, state) {
    __let ret empty
    while 1 {
        __let first token_stream_read(tokens)
        if __eq __get first 0 token.keyword.def {
            __let name token_stream_read(tokens)
            __let argc paka_read_nargs(tokens, __get name 1, state)
            __let ret __cat ret [__get name 1, argc]
        }
        if __eq length first 0 {
            return ret
        }
    }
}

def paka_parse(src) {
    __let ops [["=", "<", ">", "<=", ">=", "==", "!="]]
    __let state [ops, empty]
    __let state [ops, paka_build_defs(token_stream_new(src), state)]
    __let ret paka_read_block_body(token_stream_new(src), state)
    return ret
}

## main

def main(argv) {
    __let outfile "exec.bc"
    __let srcfile ""
    __let i 0
    while __lt i length argv {
        __let arg __get argv i 
        if __eq __get arg 0 '-' {
            if __eq __get arg 1 'o' {
                __let i __add i 1
                __let outfile __get argv i
            }
        } else {
            if __neq length srcfile 0 {
                puts("only one source can be provided")
                exit
            }
            __let srcfile arg
        }
        __let i __add i 1
    }
    if __eq length srcfile 0 {
        puts("no sources provided")
        exit
    }
    __let src read(srcfile)
    if __eq length src 0 {
        puts("cannot read file")
        exit
    }
    __let ast paka_parse(src)
    __let bc emit(ast, srcfile)
    dump(outfile, bc)
}

main(args)
exit
