def id(v) v
def empty() []
def push(x, y) __cat x [y]

## io

def put(str) {
    i = 0
    while __lt i length(str) {
        putchar(__get str i)
        i = __add i 1
    }
}

def puts(str) {
    put(str)
    putchar(10)
}

def putn_gte0(n) {
    if __gte n 10 {
        lowest = __mod n 10
        putn_gte0(__div __sub n lowest 10)
        putchar(__add lowest 48)
    } else {
        putchar(__add 48 __mod n 10)
    }
}

def putn(n) {
    if __lt n 0 {
        put("-")
        putn_gte0(__sub 0 n)
    } else {
        putn_gte0(n)
    }
}

## strings

def char_between(chr, pair) {
    if __lte __get pair 0 chr {
        if __lte chr __get pair 1 {
            return 1
        }
    }
    return 0
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return 1
    } else {
        return 0
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return 1
    }
    if char_between(chr, "AZ") {
        return 1
    }
    return 0
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return 1
    }
    if __eq chr '.' {
        return 1
    }
    if __eq chr '_' {
        return 1
    }
    return 0
}

def char_id(chr) {
    if char_id0(chr) {
        return 1
    }
    if char_isdigit(chr) {
        return 1
    }
    return 0
}

def str_starts_with(src, items) {
    if __gt length(items) length(src) {
        return 0
    }
    i = 0
    while __lt i length(items) {
        if __neq __get items i __get src i {
            return 0
        }
        i = __add i 1
    }
    return 1
}

def str.eq(sa, sb) {
    len = length(sa)
    if __neq length(sa) length(sb) {
        return 0
    }
    i = 0
    while __lt i len {
        if __neq __get sa i __get sb i {
            return 0
        }
        i = __add i 1
    }
    return 1
}

## char streams

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if __lt __get src 1 length((__get src 0)) {
        return __get __get src 0 __get src 1
    } else {
        return 0
    }
}

def stream_skip1(src) {
    if __lt __get src 1 length((__get src 0)) {
        __set src 1 __add __get src 1 1
    }
}

def stream_skip(src, n) {
    i = 0
    while __lt i n {
        stream_skip1(src)
        i = __add i 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if __gt __add length items __get src 1 length __get src 0 {
        return 0
    }
    i = 0
    while __lt i length(items) {
        if __neq __get items i __get __get src 0 __add __get src 1 i {
            return 0
        }
        i = __add i 1
    }
    return 1
}

## linker

macro link {
    data = 0
    jump = 1
    label = 2
    call = 3
    func = 4
}

def vm_link(bc) {
    nops = 0
    func_locs = empty
    sized0 = empty
    sized1 = empty
    labels = empty
    i = 0
    while __lt i length(bc) {
        cur = __get bc  i
        if __eq __get cur 0 link.func {
            func_locs = __cat func_locs [__get cur 1, nops]
        }
        if __eq __get cur 0 link.label {
            labels = __cat labels [__get cur 1, nops]
        }
        if __eq __get cur 0 link.call {
            sized0 = push sized0 cur
            nops = __add nops 1
        }
        if __eq __get cur 0 link.jump {
            sized0 = push sized0 cur
            nops = __add nops 1
        }
        if __eq __get cur 0 link.data {
            sized0 = push sized0 cur
            nops = __add nops length __get cur 1
        }
        if __gte length(sized0) 50 {
            sized1 = __cat sized1 sized0
            sized0 = empty
        }
        i = __add i 1
    }
    sized = __cat sized1 sized0
    ops0 = empty
    ops1 = empty
    ops2 = empty
    ops3 = empty
    ops4 = empty
    i = 0
    while __lt i length(sized) {
        op = __get sized i
        linktype = __get op 0
        if __eq linktype link.data {
            ops0 = __cat ops0 __get op 1
            if __gte length(ops0) 30 {
                ops1 = __cat ops1 ops0
                ops0 = empty
                if __gt length(ops1) 90 {
                    ops2 = __cat ops2 ops1
                    ops1 = empty
                    if __gt length(ops2) 300 {
                        ops3 = __cat ops3 ops2
                        ops2 = empty
                    }
                }
            }
        }
        if __eq linktype link.jump {
            found = findvar.ikey(labels, __get op 1)
            if __eq length(found) 0 {
                puts("cannot jump to undefined label")
                exit
            }
            ops0 = __cat ops0 found
        }
        if __eq linktype link.call {
            func = findvar(func_locs, __get op 1)
            if __eq length(func) 0 {
                put("link error: undefined: ")
                puts(__get op 1)
                exit
            }
            ops0 = __cat ops0 [__get func 0]
        }
        i = __add i 1
    }
    return __cat ops3 __cat ops2 __cat ops1 ops0
}

## opcodes

macro vm {
    ast.num
    ast.index
    ast.def
    ast.return
    ast.enum
    ast.when
    ast.exit
    ast.call
    ast.ident
    ast.length
    ast.import
    ast.dump
    ast.read
    ast.write
    ast.str
    ast.while
    ast.if
    ast.do
    ast.attrs
    ast.putchar
    ast.value_key
    ast.static_array
    ast.op
}

macro token {
    open.paren
    open.square
    open.curly
    close.paren
    close.square
    close.curly
    colon
    comma
    keyword.while
    keyword.if
    keyword.else
    keyword.def
    keyword.return
    keyword.macro
    keyword.exit
    op
    str
    num
    ident
}

macro opcode {
    do_exit = 0
    do_store_reg = 1
    do_branch_bool = 2
    do_store_int = 3
    do_jump = 4
    do_func = 5
    do_add = 6
    do_sub = 7
    do_mul = 8
    do_div = 9
    do_mod = 10
    do_branch_less_than_equal = 11
    do_static_call = 12
    do_return = 13
    do_putchar = 14
    do_string_new = 15
    do_length = 16
    do_index_get = 17
    do_index_set = 18
    do_dump = 19
    do_read = 20
    do_write = 21
    do_static_array_new = 22
    do_static_concat = 23
    do_branch_equal = 24
    do_branch_less = 25
}

## find variables

def findvar(vars, name) {
    i = 0
    while __lt i length(vars) {
        k = __get vars i
        i = __add i 1
        v = __get vars i
        i = __add i 1
        if str.eq(k, name) {
            return [v]
        }
    }
    return empty
}

def findvar.ikey(vars, name) {
    i = 0
    while __lt i length(vars) {
        k = __get vars i
        i = __add i 1
        v = __get vars i
        i = __add i 1
        if __eq k name {
            return [v]
        }
    }
    return empty
}

## macro resolver

def pass_macro_resolve_copy(form, state) {
    ret= [__get form 0]
    i = 1
    while __lt i length(form) {
        ret = __cat ret [pass_macro_resolve(__get form i, state)]
        i = __add i 1
    }
    return ret
}

def pass_macro_resolve_enum(form, state) {
    name = __get __get form 1 1
    idents = empty
    where = 1
    while __lt where length(__get form 2) {
        ok = 0
        if __eq __get __get __get form 2 where 0 vm.ast.ident {
            fullname = __cat __get __get form 1 1 __cat "." __get __get __get form 2 where 1
            ast= [vm.ast.num, where]
            __set state 0 __cat __get state 0 [fullname, ast]
            ok = 1
        }
        if __eq __get __get __get form 2 where 0 vm.ast.op {
            if str.eq(__get __get __get form 2 where 1, "=") {
                setto = __get __get __get form 2 where 2
                val = __get __get __get form 2 where 3
                if __neq __get setto 0 vm.ast.ident {
                    puts("enum macro given bad value on left hand size of `=`")
                    exit
                }
                fullname = __cat __get __get form 1 1 __cat "." __get setto 1
                __set state 0 __cat __get state 0 [fullname, val]
                ok = 1
            }
        }
        if __eq ok 0 {
            puts("that is not valid in a macro")
            exit
        }
        where = __add where 1
    }
    return [vm.ast.do]
}
 
def pass_macro_resolve(form, state) {
    ty = __get form 0
    if __eq ty vm.ast.num {
        return form
    }
    if __eq ty vm.ast.str {
        return form
    }
    if __eq ty vm.ast.attrs {
        return form
    }
    if __eq ty vm.ast.ident {
        val = findvar(__get state 0, __get form 1)
        if __neq length(val) 0 {
            return __get val 0
        }
        return form
    }
    if __eq ty vm.ast.op {
        return [ty, __get form 1, pass_macro_resolve(__get form 2, state), pass_macro_resolve(__get form 3, state)]
    }
    if __eq ty vm.ast.enum {
        return pass_macro_resolve_enum(form, state)
    }
    if __eq ty vm.ast.def {
        return pass_macro_resolve_copy(form, state)
    }
    return pass_macro_resolve_copy(form, state)
}

## emit

def put_reg(out) {
    __set out 1 __add __get out 1 1
    return __get out 1
}

def emit_num(form, out) {
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_int, ret, __get form 1])])]
    return ret
}

def emit_binop(op, form1, form2, out) {
    r1 = emit_to(form1, out)
    r2 = emit_to(form2, out)
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([op, ret, r1, r2])])]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(__get form 1, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_putchar, r1])])]
    return 0
}

def emit_length(form, out) {
    r1 = emit_to(__get form 1, out)
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_length, ret, r1])])]
    return ret
}

def emit_do(form, out) {
    ret = 0
    i = 1
    while __lt i length(form) {
        ret = emit_to(__get form i, out)
        i = __add i 1
    } 
    return ret
}

def emit_ident(form, out) {
    res = findvar(__get out 2, __get form 1)
    if __eq length(res) 0 {
        puts(__cat "unknown ident: " __get form 1)
        exit
    }
    return __get res 0
}

def emit_set(from, to, out) {
    if __eq __get from 0 vm.ast.ident {
        found = findvar(__get out 2, __get from 1)
        if __eq length(found) 0 {
            varreg = emit_to(to, out)
            to = put_reg(out)
            __set out 2 __cat __get out 2 [__get from 1, to]
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, to, varreg])])]
            return to
        } else {
            from = emit_to(to, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, __get found 0, from])])]
            return __get found 0
        }
    }
    if __eq __get from 0 vm.ast.index {
        array = emit_to(__get from 1, out)
        index = emit_to(__get from 2, out)
        varreg = emit_to(to, out)
        __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_index_set, array, index, varreg])])]
        return array
    }
    put("cannot __set to: ")
    putn(__get from 0)
    putchar(10)
    exit
}

def put_jump(out) {
    count = __get out 3
    __set out 3 __add __get out 3 1
    return count
}

def put_goto(jump) {
    return [link.jump, jump] 
}

def put_label(jump) {
    return [link.label, jump]
}

def emit_def(form, out) {
    jover = put_jump(out)
    call = __get form 1
    body = __get form 2
    tmp1 = __get out 1
    tmp2 = __get out 2
    __set out 2 empty
    i = 2
    while __lt i length(call) {
        __set out 2 __cat __get out 2 [__get __get call i 1, __sub i 1]
        i = __add i 1
    }
    __set out 1 __sub i 1
    nregs = [link.data, [256]]
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_func])]), put_goto(jover), nregs, id([link.func, __get __get call 1 1])]
    resreg = emit_to(body, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_return, resreg])])]
    __set __get nregs 1 0 __get out 1
    __set out 1 tmp1
    __set out 2 tmp2
    __set out 0 __cat __get out 0 [put_label(jover)]
    return 0
}

def emit_return(form, out) {
    rreg = emit_to(__get form 1, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_return, rreg])])]
    return 0
}

def emit_exit(form, out) {
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_exit])])]
    return 0
}

def emit_call(form, out) {
    if __eq __get __get form 1 0 vm.ast.ident {
        args = empty
        i = 2
        while __lt i length(form) {
            args = push args emit_to(__get form i, out)
            i = __add i 1
        } 
        ret = put_reg(out)
        __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_static_call, ret])]), id([link.call, __get __get form 1 1]), id([link.data, __cat id([length(args)]) args])]
        return ret
    } else {
        puts("no dynamic calls yet")
        exit
    }
}

def emit_branch_alike(cond, jfalse, jtrue, out) {
    if __eq __get cond 0 vm.ast.op {
        first = __get __get cond 1 0
        if str.eq(__get cond 1, ">") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less, rhs, lhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "<=") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less_than_equal, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "==") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_equal, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, "!=") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_equal, lhs, rhs])]),put_goto(jtrue), put_goto(jfalse)]
            return 0
        }
        if str.eq(__get cond 1, "<") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less, lhs, rhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(__get cond 1, ">=") {
            lhs = emit_to(__get cond 2, out)
            rhs = emit_to(__get cond 3, out)
            __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_less_than_equal, rhs, lhs])]),put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
    }
    reg = emit_to(cond, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_branch_bool, reg])]),put_goto(jfalse), put_goto(jtrue)]
    return 0
}

def emit_while(form, out) {
    jredo = put_jump(out)
    jtrue = put_jump(out)
    jfalse = put_jump(out)
    __set out 0 __cat __get out 0 [put_label(jredo)]
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    __set out 0 __cat __get out 0 [put_label(jtrue)]
    emit_to(__get form 2, out)
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    __set out 0 __cat __get out 0 [put_label(jfalse)]
    return 0
}

def emit_if(form, out) {
    jout = put_jump(out)
    jtrue = put_jump(out)
    jfalse = put_jump(out)
    emit_branch_alike(__get form 1, jfalse, jtrue, out)
    rret = put_reg(out)
    __set out 0 __cat __get out 0 [put_label(jtrue)]
    rtrue = emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, rret, rtrue, opcode.do_jump])]),put_goto(jout), put_label(jfalse)]
    rfalse = emit_to(__get form 3, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_store_reg, rret, rfalse])])]
    __set out 0 __cat __get out 0 [put_label(jout)]
    return rret
}

def emit_array(form, out) {
    regs = empty
    i = 1
    while __lt i length(form) {
        regs = __cat regs [emit_to(__get form i, out)]
        i = __add i 1
    }
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_static_array_new, ret, length(regs)]) regs])]
    return ret
}

def emit_static_array(form, out) {
    regs = empty
    i = 1
    while __lt i length(form) {
        regs = __cat regs [emit_to(__get form i, out)]
        i = __add i 1
    }
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_static_array_new, ret, length(regs)]) regs])]
    return ret
}

def emit_str(form, out) {
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, __cat id([opcode.do_string_new, ret, length(__get form 1)]) __get form 1])]
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(__get form 1, out)
    r2 = emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_dump, r1, r2])])]
    return 0
}

def emit_write(form, out) {
    r1 = emit_to(__get form 1, out)
    r2 = emit_to(__get form 2, out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_write, r1, r2])])]
    return 0
}

def emit_read(form, out) {
    r1 = emit_to(__get form 1, out)
    ret = put_reg(out)
    __set out 0 __cat __get out 0 [id([link.data, id([opcode.do_read, ret, r1])])]
    return ret
}

def emit_to(form, out) {
    ty = __get form 0
    if __eq ty vm.ast.num {
        return emit_num(form, out)
    }
    if __eq ty vm.ast.index {
        return emit_binop(opcode.do_index_get, __get form 1, __get form 2, out)
    }
    if __eq ty vm.ast.def {
        if __gt length(__get out 0) 50 {
            __set out 4 __cat __get out 4 __get out 0
            __set out 0 empty
        }
        return emit_def(form, out)
    }
    if __eq ty vm.ast.return {
        return emit_return(form, out)
    }
    if __eq ty vm.ast.exit {
        return emit_exit(form, out)
    }
    if __eq ty vm.ast.call {
        return emit_call(form, out)
    }
    if __eq ty vm.ast.ident {
        return emit_ident(form, out)
    }
    if __eq ty vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if __eq ty vm.ast.length {
        return emit_length(form, out)
    }
    if __eq ty vm.ast.dump {
        return emit_dump(form, out)
    }
    if __eq ty vm.ast.read {
        return emit_read(form, out)
    }
    if __eq ty vm.ast.write {
        return emit_write(form, out)
    }
    if __eq ty vm.ast.static_array {
        return emit_static_array(form, out)
    }
    if __eq ty vm.ast.str {
        return emit_str(form, out)
    }
    if __eq ty vm.ast.while {
        return emit_while(form, out)
    }
    if __eq ty vm.ast.if {
        return emit_if(form, out)
    }
    if __eq ty vm.ast.do {
        return emit_do(form, out)
    }
    if __eq ty vm.ast.op {
        op = __get __get form 1 0
        if __eq op '=' {
            return emit_set(__get form 2, __get form 3, out)
        }
        if __eq op '~' {
            return emit_binop(opcode.do_static_concat, __get form 2, __get form 3, out)
        }
        if __eq op '+' {
            return emit_binop(opcode.do_add, __get form 2, __get form 3, out)
        }
        if __eq op '-' {
            return emit_binop(opcode.do_sub, __get form 2, __get form 3, out)
        }
        if __eq op '*' {
            return emit_binop(opcode.do_mul, __get form 2, __get form 3, out)
        }
        if __eq op '/' {
            return emit_binop(opcode.do_div, __get form 2, __get form 3, out)
        }
        if __eq op '%' {
            return emit_binop(opcode.do_mod, __get form 2, __get form 3, out)
        }
        puts("emit: form: unknown op")
        exit
    }
    puts("emit: form: unknown form")
    exit
}

def emit(form, path) {
    out= [empty, 0, id(["args", 0]), 0, empty, empty]
    form = pass_macro_resolve(form, [empty])
    emit_to(form, out)
    objc = __cat __get out 4 __cat __get out 0 [id([link.data, id([opcode.do_exit])])]
    linked = vm_link(objc)
    return linked
}

## paka

def paka_tokenize_stream1(bsrc, ops_flat) {
    first = stream_peek(bsrc)
    if __eq first ' ' {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if __eq first 10 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if __eq first 13 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if __eq first '#' {
        stream_skip1(bsrc)
        while 1 {
            cur = stream_read(bsrc)
            if __eq cur 10 {
                return paka_tokenize_stream1(bsrc, ops_flat)
            }
            if __eq cur 13 {
                return paka_tokenize_stream1(bsrc, ops_flat)
            }
        }
    }
    if __eq first '(' {
        stream_skip1(bsrc)
        return [token.open.paren]
    }
    if __eq first ')' {
        stream_skip1(bsrc)
        return [token.close.paren]
    }
    if __eq first '{' {
        stream_skip1(bsrc)
        return [token.open.curly]
    }
    if __eq first '}' {
        stream_skip1(bsrc)
        return [token.close.curly]
    }
    if __eq first '[' {
        stream_skip1(bsrc)
        return [token.open.square]
    }
    if __eq first ']' {
        stream_skip1(bsrc)
        return [token.close.square]
    }
    if __eq first ',' {
        stream_skip1(bsrc)
        return [token.comma]
    }
    if __eq first ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if __eq cur '\\' {
            cur = stream_read(bsrc)
            if __neq stream_read(bsrc) ''' {
                puts("unterminated char literal")
                exit
            }
            if __eq cur 'n' {
                return [token.num, 10]
            } 
            if __eq cur 'r' {
                return [token.num, 13]
            } 
            if __eq cur 34 {
                return [token.num, cur]
            }
            if __eq cur '\\' {
                return [token.num, cur]
            }
        } else {
            if __neq stream_read(bsrc) ''' {
                puts("unterminated char literal")
                exit
            }
            return [token.num, cur]
        }
    }
    if __eq first 34 {
        stream_skip1(bsrc)
        ret = empty
        while 1 {
            cur = stream_read(bsrc)
            if __eq cur 0 {
                puts("eof in str")
                exit
            }
            if __eq cur 34 {
                return [token.str, ret]
            }
            if __eq cur '\\' {
                cur = stream_read(bsrc)
                if __eq cur 'n' {
                    ret = push ret 10
                } 
                if __eq cur 34 {
                    ret = __cat ret "\""
                }
                if __eq cur '\\' {
                    ret = __cat ret "\\"
                }
            } else {
                ret = push ret cur
            }
        }
    }
    i = 0
    while __lt i length(ops_flat) {
        if stream_starts_swith(bsrc, __get ops_flat i) {
            stream_skip(bsrc, length(__get ops_flat i))
            return [token.op, __get ops_flat i]
        }
        i = __add i 1
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = __add __mul n 10 __sub stream_read(bsrc) '0'
        }
        return [token.num, n]
    }
    if char_id0(first) {
        xsrc = empty
        while 1 {
            if char_id(stream_peek(bsrc)) {
                xsrc = push xsrc stream_read(bsrc)
            } else {
                n0 = __get xsrc 0
                if __eq n0 'w' {
                    if str.eq(xsrc, "while") {
                        return [token.keyword.while]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'i' {
                    if str.eq(xsrc, "if") {
                        return [token.keyword.if]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'e' {
                    if str.eq(xsrc, "else") {
                        return [token.keyword.else]
                    }
                    if str.eq(xsrc, "exit") {
                        return [token.keyword.exit]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'd' {
                    if str.eq(xsrc, "def") {
                        return [token.keyword.def]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'r' {
                    if str.eq(xsrc, "return") {
                        return [token.keyword.return]
                    }
                    return [token.ident, xsrc]
                }
                if __eq n0 'm' {
                    if str.eq(xsrc, "macro") {
                        return [token.keyword.macro]
                    }
                    return [token.ident, xsrc]
                }
                return [token.ident, xsrc]
            }
        }
    }
    if __eq first 0 {
        return empty
    }
    put("bad char: code ")
    putn(first)
    putchar(10)
    exit
}

def token_stream_new(src) {
    ops_flat= ["<=", ">=", "==", "!=", "<", ">", "="]
    ssrc= [src, 0]
    return [ops_flat, ssrc, empty]
}

def token_stream_read(tokens) {
    ret = token_stream_peek(tokens)
    token_stream_skip1(tokens)
    return ret
}

def token_stream_peek(tokens) {
    if __eq length(__get tokens 2) 0 {
        __set tokens 2 paka_tokenize_stream1(__get tokens 1, __get tokens 0)
    }
    return __get tokens 2
}

def token_stream_skip1(tokens) {
    if __eq length(__get tokens 2) 0 {
        paka_tokenize_stream1(__get tokens 1, __get tokens 0)
    }
    __set tokens 2 empty
}

def paka_skip_comma(tokens) {
    first = token_stream_peek(tokens)
    if __eq __get first 0 token.comma {
        token_stream_skip1(tokens)
    }
}

def paka_read_scall(tokens, nargs, args, state) {
    target = __add nargs length(args)
    got = token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if __eq length(cur) 0 {
                puts("error eof arg")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                if __neq length(args) target {
                    puts("error: argc")
                    exit
                }
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = push args arg
            paka_skip_comma(tokens)
        }
    }
    while __lt length(args) target {
        cur = token_stream_peek(tokens)
        if __eq length(cur) 0 {
            puts("error eof arg")
        }
        arg = paka_read_expr_base(tokens, state)
        args = push args arg
        paka_skip_comma(tokens)
    }
    return paka_read_post(tokens, args, state)
}

def paka_read_call(tokens, args, state) {
    got = token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if __eq length(cur) 0 {
                puts("error 1")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = push args arg
            paka_skip_comma(tokens)
        }
    }
    puts("error: wanted `(`")
    exit
}

def paka_read_post(tokens, last, state) {
    first = token_stream_peek(tokens)
    if __eq length(first) 0 {
        return last
    }
    if __eq __get first 0 token.open.paren {
        if __neq __get last 0 vm.ast.ident {
            put("cannot call anything but idents: ")
            putn(__get last 0)
            putchar(10)
            exit
        }
        found = findvar(__get state 1, __get last 1)
        if __eq length(found) 0 {
            args= [vm.ast.call, last] 
            return paka_read_call(tokens, args, state)
        } else {
            args= [vm.ast.call, last] 
            return paka_read_scall(tokens, __get found 0, args, state)
        }
    }
    if __eq __get last 0 vm.ast.ident {
        found = findvar(__get state 1, __get last 1)
        if __eq length(found) 1 {
            args= [vm.ast.call, last] 
            return paka_read_scall(tokens, __get found 0, args, state)
        }
    }
    return last
}

def paka_read_single(tokens, state) {
    first = token_stream_peek(tokens)
    if __eq length(first) 0 {
        return 0
    }
    if __eq __get first 0 token.open.square {
        token_stream_skip1(tokens)
        args= [vm.ast.static_array]
        while 1 {
            cur = token_stream_peek(tokens)
            if __eq __get cur 0 token.close.square {
                token_stream_skip1(tokens)
                return args
            }
            expr = paka_read_expr_base(tokens, state)
            args = push args expr
            paka_skip_comma(tokens)
        } 
    }
    if __eq __get first 0 token.open.paren {
        token_stream_skip1(tokens)
        ret = paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    if __eq __get first 0 token.num {
        token_stream_skip1(tokens)
        return [vm.ast.num, __get first 1]
    }
    if __eq __get first 0 token.str {
        token_stream_skip1(tokens)
        return [vm.ast.str, __get first 1]
    }
    if __eq __get first 0 token.ident {
        token_stream_skip1(tokens)
        if str.eq(__get first 1, "putchar") {
            return paka_read_scall(tokens, 1, [vm.ast.putchar], state)
        } 
        if str.eq(__get first 1, "length") {
            return paka_read_scall(tokens, 1, [vm.ast.length], state)
        }
        if str.eq(__get first 1, "dump") {
            return paka_read_scall(tokens, 2, [vm.ast.dump], state)
        }
        if str.eq(__get first 1, "write") {
            return paka_read_scall(tokens, 2, [vm.ast.write], state)
        }
        if str.eq(__get first 1, "read") {
            return paka_read_scall(tokens, 1, [vm.ast.read], state)
        }
        if str.eq(__get first 1, "read") {
        }
        if __eq __get __get first 1 0 '_' {
            if str.eq(__get first 1, "__get") {
                return paka_read_scall(tokens, 2, [vm.ast.index], state)
            }
            if str.eq(__get first 1, "__set") {
                args = paka_read_scall(tokens, 3, empty, state)
                return [vm.ast.op, "=", [vm.ast.index, __get args 0, __get args 1], __get args 2]
            }
            if str.eq(__get first 1, "__add") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "+"], state)
            }
            if str.eq(__get first 1, "__sub") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "-"], state)
            }
            if str.eq(__get first 1, "__mul") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "*"], state)
            }
            if str.eq(__get first 1, "__div") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "/"], state)
            }
            if str.eq(__get first 1, "__mod") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "%"], state)
            }
            if str.eq(__get first 1, "__cat") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "~"], state)
            }
            if str.eq(__get first 1, "__lt") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "<"], state)
            }
            if str.eq(__get first 1, "__gt") {
                return paka_read_scall(tokens, 2, [vm.ast.op, ">"], state)
            }
            if str.eq(__get first 1, "__lte") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "<="], state)
            }
            if str.eq(__get first 1, "__gte") {
                return paka_read_scall(tokens, 2, [vm.ast.op, ">="], state)
            }
            if str.eq(__get first 1, "__eq") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "=="], state)
            }
            if str.eq(__get first 1, "__neq") {
                return paka_read_scall(tokens, 2, [vm.ast.op, "!="], state)
            }
        }
        return [vm.ast.ident, __get first 1]
    }
    if __eq __get first 0 token.keyword.if {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block1 = paka_read_block(tokens, state)
        block2= [vm.ast.do]
        first = token_stream_peek(tokens)
        if __eq __get first 0 token.keyword.else {
            token_stream_skip1(tokens)
            block2 = paka_read_block(tokens, state)
        }
        return [vm.ast.if, expr, block1, block2]
    }
    put("error: unexpected token#")
    putn(__get first 0)
    puts(".")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while __lt i length(some) {
        if str.eq(op, __get some i) {
            return 0
        }
        i = __add i 1
    }
    return 1
}

def paka_read_expr(tokens, depth, state) {
    ops = __get state 0
    if __gte depth length(ops) {
        return paka_read_post(tokens, paka_read_single(tokens, state), state)
    }
    ret = paka_read_expr(tokens, __add depth 1, state)
    while 1 {
        first = token_stream_peek(tokens)
        if __eq length(first) 0 {
        return ret
        }
        if __neq __get first 0 token.op {
            return ret
        }
        if parse_is_not_in(__get first 1, __get ops depth) {
            return ret
        }
        token_stream_skip1(tokens)
        ret= [vm.ast.op, __get first 1, ret, paka_read_expr(tokens, __add depth 1, state)]
    }
}

def paka_read_expr_base(tokens, state) {
    ret = paka_read_expr(tokens, 0, state)
    return ret
}

def paka_read_stmt(tokens, state) {
    first = token_stream_peek(tokens)
    if __eq __get first 0 token.keyword.while {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.while, expr, block]
    }
    if __eq __get first 0 token.keyword.def {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.def, expr, block]
    }
    if __eq __get first 0 token.keyword.return {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        return [vm.ast.return, expr]
    }
    if __eq __get first 0 token.keyword.macro {
        token_stream_skip1(tokens)
        name = token_stream_read(tokens)
        first = token_stream_peek(tokens)
        block = paka_read_block(tokens, state)
        return [vm.ast.enum, id([vm.ast.ident, __get name 1]), block]
    }
    if __eq __get first 0 token.keyword.exit {
        token_stream_skip1(tokens)
        return [vm.ast.exit]
    }
    ret = paka_read_expr_base(tokens, state)
    return ret
}

def paka_read_block_body(tokens, state) {
    ret= [vm.ast.do]
    while 1 {
        first = token_stream_peek(tokens)
        if __eq length(first) 0 {
            return ret
        }
        if __eq __get first 0 token.close.curly {
            return ret
        }
        stmt = paka_read_stmt(tokens, state)
        ret = push ret stmt
    }
}

def paka_read_block(tokens, state) {
    first = token_stream_peek(tokens)
    if __eq __get first 0 token.open.curly {
        token_stream_skip1(tokens)
        ret = paka_read_block_body(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    return [vm.ast.do, paka_read_stmt(tokens, state)]
}

def paka_read_nargs(tokens, name, state) {
    got = token_stream_peek(tokens)
    if __eq __get got 0  token.open.paren {
        token_stream_skip1(tokens)
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if __eq length(cur) 0 {
                puts("error: need `)` after args to def")
                exit
            }
            if __eq __get cur 0 token.close.paren {
                token_stream_skip1(tokens)
                return n
            }
            paka_read_expr_base(tokens, state)
            n = __add n 1
            paka_skip_comma(tokens)
        }
    } else {
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if __eq length(cur) 0 {
                puts("error: need `:` after def")
            }
            if __eq __get cur 0 token.op {
                if str.eq(__get cur 1, ":") {
                    token_stream_skip1(tokens)
                    return n
                }
            }
            paka_read_expr_base(tokens, state)
            n = __add n 1
            paka_skip_comma(tokens)
        }
    }
}

def paka_build_defs(tokens, state) {
    ret = empty
    while 1 {
        first = token_stream_read(tokens)
        if __eq __get first 0 token.keyword.def {
            name = token_stream_read(tokens)
            argc = paka_read_nargs(tokens, __get name 1, state)
            ret = __cat ret [__get name 1, argc]
        }
        if __eq length(first) 0 {
            return ret
        }
    }
}

def paka_parse(src) {
    ops = [["=", "<", ">", "<=", ">=", "==", "!="]]
    state= [ops, empty]
    state= [ops, paka_build_defs(token_stream_new(src), state)]
    ret = paka_read_block_body(token_stream_new(src), state)
    return ret
}

## main

def main(argv) {
    outfile = "exec.bc"
    srcfile = ""
    i = 0
    while __lt i length(argv) {
        arg = __get argv i 
        if __eq __get arg 0 '-' {
            if __eq __get arg 1 'o' {
                i = __add i 1
                outfile = __get argv i
            }
        } else {
            if __neq length(srcfile) 0 {
                puts("only one source can be provided")
                exit
            }
            srcfile = arg
        }
        i = __add i 1
    }
    if __eq length(srcfile) 0 {
        puts("no sources provided")
        exit
    }
    src = read(srcfile)
    if __eq length(src) 0 {
        puts("cannot read file")
        exit
    }
    ast = paka_parse(src)
    bc = emit(ast, srcfile)
    dump(outfile, bc)
}

main(args)
exit
