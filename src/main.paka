def empty() []
def push(x y) cat x [y]

## io

def put(str) {
    let i 0
    while lt i length str {
        putchar get str i
        let i add i 1
    }
}

def puts(str) {
    put str
    putchar 10
}

def putn_gte0(n) {
    if gte n 10 {
        let lowest mod n 10
        putn_gte0 div sub n lowest 10
        putchar add lowest 48
    } else {
        putchar add 48 mod n 10
    }
}

def putn(n) {
    if lt n 0 {
        put "-"
        putn_gte0 sub 0 n
    } else {
        putn_gte0 n
    }
}

## strings

def char_between(chr pair) {
    if lte get pair 0 chr {
        if lte chr get pair 1 {
            return 1
        }
    }
    return 0
}
 
def char_isdigit(chr) {
    if char_between chr "09" {
        return 1
    } else {
        return 0
    }
}

def char_isalpha(chr) {
    if char_between chr "az" {
        return 1
    } else if char_between chr "AZ" {
        return 1
    } else {
        return 0
    }
}

def char_id(char) {
    if eq char '[' return 0
    else if eq char ']' return 0 
    else if eq char '(' return 0
    else if eq char ')' return 0 
    else if eq char '{' return 0
    else if eq char '}' return 0 
    else if eq char '}' return 0 
    else if eq char ''' return 0 
    else if eq char 34 return 0 
    else if eq char '\n' return 0 
    else if eq char ' ' return 0 
    else if eq char 0 return 0 
    else return 1
}

def str_starts_with(src items) {
    if gt length items length src {
        return 0
    }
    let i 0
    while lt i length items {
        if neq get items i get src i {
            return 0
        }
        let i add i 1
    }
    return 1
}

def str.eq(sa sb) {
    let len length sa
    if neq length sa length sb {
        return 0
    }
    let i 0
    while lt i len {
        if neq get sa i get sb i {
            return 0
        }
        let i add i 1
    }
    return 1
}

## char streams

def stream_new(src) {
    return [src 0]
}

def stream_peek(src) {
    if lt get src 1 length get src 0 {
        return get get src 0 get src 1
    } else {
        return 0
    }
}

def stream_skip1(src) {
    if lt get src 1 length get src 0 {
        set src 1 add get src 1 1
    }
}

def stream_skip(src n) {
    let i 0
    while lt i n {
        stream_skip1 src
        let i add i 1
    }
}

def stream_read(src) {
    let ret stream_peek src
    stream_skip1 src
    return ret
}

def stream_starts_swith(src items) {
    if gt add length items get src 1 length get src 0 {
        return 0
    }
    let i 0
    while lt i length items {
        if neq get items i get get src 0 add get src 1 i {
            return 0
        }
        let i add i 1
    }
    return 1
}

## linker

macro link {
    let data 0
    let jump 1
    let label 2
    let call 3
    let func 4
}

def vm_link(bc) {
    let nops 0
    let func_locs empty
    let sized0 empty
    let sized1 empty
    let labels empty
    let i 0
    while lt i length bc {
        let cur get bc  i
        if eq get cur 0 link.func {
            let func_locs cat func_locs [get cur 1 nops]
        }
        if eq get cur 0 link.label {
            let labels cat labels [get cur 1 nops]
        }
        if eq get cur 0 link.call {
            let sized0 push sized0 cur
            let nops add nops 1
        }
        if eq get cur 0 link.jump {
            let sized0 push sized0 cur
            let nops add nops 1
        }
        if eq get cur 0 link.data {
            let sized0 push sized0 cur
            let nops add nops length get cur 1
        }
        if gte length sized0 50 {
            let sized1 cat sized1 sized0
            let sized0 empty
        }
        let i add i 1
    }
    let sized cat sized1 sized0
    let ops0 empty
    let ops1 empty
    let ops2 empty
    let ops3 empty
    let ops4 empty
    let i 0
    while lt i length sized {
        let op get sized i
        let linktype get op 0
        if eq linktype link.data {
            let ops0 cat ops0 get op 1
            if gte length ops0 30 {
                let ops1 cat ops1 ops0
                let ops0 empty
                if gt length ops1 90 {
                    let ops2 cat ops2 ops1
                    let ops1 empty
                    if gt length ops2 300 {
                        let ops3 cat ops3 ops2
                        let ops2 empty
                    }
                }
            }
        }
        if eq linktype link.jump {
            let found findvar.ikey labels get op 1
            if eq length found 0 {
                puts "cannot jump to undefined label"
                exit
            }
            let ops0 cat ops0 found
        }
        if eq linktype link.call {
            let func findvar func_locs get op 1
            if eq length func 0 {
                put "link error: undefined: "
                puts get op 1
                exit
            }
            let ops0 cat ops0 [get func 0]
        }
        let i add i 1
    }
    return cat ops3 cat ops2 cat ops1 ops0
}

## opcodes

macro vm {
    ast.num
    ast.index
    ast.def
    ast.return
    ast.enum
    ast.exit
    ast.call
    ast.ident
    ast.length
    ast.import
    ast.dump
    ast.read
    ast.write
    ast.str
    ast.while
    ast.if
    ast.do
    ast.attrs
    ast.putchar
    ast.value_key
    ast.static_array
    ast.op
}

macro token {
    open.paren
    open.square
    open.curly
    close.paren
    close.square
    close.curly
    keyword.while
    keyword.if
    keyword.else
    keyword.def
    keyword.return
    keyword.macro
    keyword.exit
    keyword.cond
    op
    str
    num
    ident
}

macro opcode {
    let do_exit 0
    let do_store_reg 1
    let do_branch_bool 2
    let do_store_int 3
    let do_jump 4
    let do_func 5
    let do_add 6
    let do_sub 7
    let do_mul 8
    let do_div 9
    let do_mod 10
    let do_branch_less_than_equal 11
    let do_static_call 12
    let do_return 13
    let do_putchar 14
    let do_string_new 15
    let do_length 16
    let do_index_get 17
    let do_index_set 18
    let do_dump 19
    let do_read 20
    let do_write 21
    let do_static_array_new 22
    let do_static_concat 23
    let do_branch_equal 24
    let do_branch_less 25
}

## find variables

def findvar(vars name) {
    let i 0
    while lt i length vars {
        let k get vars i
        let i add i 1
        let v get vars i
        let i add i 1
        if str.eq k name {
            return [v]
        }
    }
    return empty
}

def findvar.ikey(vars name) {
    let i 0
    while lt i length vars {
        let k get vars i
        let i add i 1
        let v get vars i
        let i add i 1
        if eq k name {
            return [v]
        }
    }
    return empty
}

## macro resolver

def pass_macro_resolve_copy(form state) {
    let ret [get form 0]
    let i 1
    while lt i length form {
        let ret cat ret [pass_macro_resolve get form i state]
        let i add i 1
    }
    return ret
}

def pass_macro_resolve_enum(form state) {
    let name get get form 1 1
    let idents empty
    let where 1
    while lt where length get form 2 {
        let ok 0
        if eq get get get form 2 where 0 vm.ast.ident {
            let fullname cat get get form 1 1 cat "." get get get form 2 where 1
            let ast [vm.ast.num where]
            set state 0 cat get state 0 [fullname ast]
            let ok 1
        }
        if eq get get get form 2 where 0 vm.ast.op {
            if str.eq get get get form 2 where 1 "=" {
                let setto get get get form 2 where 2
                let val get get get form 2 where 3
                if neq get setto 0 vm.ast.ident {
                    puts "enum macro given bad value on left hand size of `=`"
                    exit
                }
                let fullname cat get get form 1 1 cat "." get setto 1
                set state 0 cat get state 0 [fullname val]
                let ok 1
            }
        }
        if eq ok 0 {
            puts "that is not valid in a macro"
            exit
        }
        let where add where 1
    }
    return [vm.ast.do]
}
 
def pass_macro_resolve(form state) {
    let ty get form 0
    if eq ty vm.ast.num {
        return form
    }
    if eq ty vm.ast.str {
        return form
    }
    if eq ty vm.ast.attrs {
        return form
    }
    if eq ty vm.ast.ident {
        let val findvar get state 0 get form 1
        if neq length val 0 {
            return get val 0
        }
        return form
    }
    if eq ty vm.ast.op {
        return [ty get form 1 pass_macro_resolve get form 2 state pass_macro_resolve get form 3 state]
    }
    if eq ty vm.ast.enum {
        return pass_macro_resolve_enum form state
    }
    if eq ty vm.ast.def {
        return pass_macro_resolve_copy form state
    }
    return pass_macro_resolve_copy form state
}

## emit

def put_reg(out) {
    set out 1 add get out 1 1
    return get out 1
}

def emit_num(form out) {
    let ret put_reg out
    set out 0 cat get out 0 [[link.data [opcode.do_store_int ret get form 1]]]
    return ret
}

def emit_binop(op form1 form2 out) {
    let r1 emit_to form1 out
    let r2 emit_to form2 out
    let ret put_reg out
    set out 0 cat get out 0 [[link.data [op ret r1 r2]]]
    return ret
}

def emit_putchar(form out) {
    let r1 emit_to get form 1 out
    set out 0 cat get out 0 [[link.data [opcode.do_putchar r1]]]
    return 0
}

def emit_length(form out) {
    let r1 emit_to get form 1 out
    let ret put_reg out
    set out 0 cat get out 0 [[link.data [opcode.do_length ret r1]]]
    return ret
}

def emit_do(form out) {
    let ret 0
    let i 1
    while lt i length form {
        let ret emit_to get form i out
        let i add i 1
    } 
    return ret
}

def emit_ident(form out) {
    let res findvar get out 2 get form 1
    if eq length res 0 {
        puts cat "unknown ident: " get form 1
        exit
    }
    return get res 0
}

def emit_set(from to out) {
    if eq get from 0 vm.ast.ident {
        let found findvar get out 2 get from 1
        if eq length found 0 {
            let varreg emit_to to out
            let to put_reg out
            set out 2 cat get out 2 [get from 1 to]
            set out 0 cat get out 0 [[link.data [opcode.do_store_reg to varreg]]]
            return to
        } else {
            let from emit_to to out
            set out 0 cat get out 0 [[link.data [opcode.do_store_reg get found 0 from]]]
            return get found 0
        }
    }
    if eq get from 0 vm.ast.index {
        let array emit_to get from 1 out
        let index emit_to get from 2 out
        let varreg emit_to to out
        set out 0 cat get out 0 [[link.data [opcode.do_index_set array index varreg]]]
        return array
    }
    put "cannot set to: form#"
    putn get from 0
    putchar 10
    exit
}

def put_jump(out) {
    let count get out 3
    set out 3 add get out 3 1
    return count
}

def put_goto(jump) {
    return [link.jump jump] 
}

def put_label(jump) {
    return [link.label jump]
}

def emit_def(form out) {
    let jover put_jump out
    let call get form 1
    let body get form 2
    let tmp1 get out 1
    let tmp2 get out 2
    set out 2 empty
    let i 2
    while lt i length call {
        set out 2 cat get out 2 [get get call i 1 sub i 1]
        let i add i 1
    }
    set out 1 sub i 1
    let nregs [link.data [256]]
    set out 0 cat get out 0 [[link.data [opcode.do_func]] put_goto jover [link.data cat [sub length call 2 length get get call 1 1] get get call 1 1] nregs [link.func get get call 1 1]]
    let resreg emit_to body out
    set out 0 cat get out 0 [[link.data [opcode.do_return resreg]]]
    set get nregs 1 0 get out 1
    set out 1 tmp1
    set out 2 tmp2
    set out 0 cat get out 0 [put_label jover]
    return 0
}

def emit_return(form out) {
    let rreg emit_to get form 1 out
    set out 0 cat get out 0 [[link.data [opcode.do_return rreg]]]
    return 0
}

def emit_exit(form out) {
    set out 0 cat get out 0 [[link.data [opcode.do_exit]]]
    return 0
}

def emit_call(form out) {
    if eq get get form 1 0 vm.ast.ident {
        let args empty
        let i 2
        while lt i length form {
            let args push args emit_to get form i out
            let i add i 1
        } 
        let ret put_reg out
        set out 0 cat get out 0 [[link.data [opcode.do_static_call ret]] [link.call get get form 1 1] [link.data cat [length args] args]]
        return ret
    } else {
        puts "no dynamic calls yet"
        exit
    }
}

def emit_branch_alike(xcond jfalse jtrue out) {
    if eq get xcond 0 vm.ast.op {
        let first get get xcond 1 0
        if str.eq get xcond 1 ">" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_less rhs lhs]] put_goto jfalse put_goto jtrue]
            return 0
        }
        if str.eq get xcond 1 "<=" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_less_than_equal lhs rhs]] put_goto jfalse put_goto jtrue]
            return 0
        }
        if str.eq get xcond 1 "==" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_equal lhs rhs]] put_goto jfalse put_goto jtrue]
            return 0
        }
        if str.eq get xcond 1 "!=" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_equal lhs rhs]] put_goto jtrue put_goto jfalse]
            return 0
        }
        if str.eq get xcond 1 "<" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_less lhs rhs]] put_goto jfalse put_goto jtrue]
            return 0
        }
        if str.eq get xcond 1 ">=" {
            let lhs emit_to get xcond 2 out
            let rhs emit_to get xcond 3 out
            set out 0 cat get out 0 [[link.data [opcode.do_branch_less_than_equal rhs lhs]] put_goto jfalse put_goto jtrue]
            return 0
        }
    }
    let reg emit_to xcond out
    set out 0 cat get out 0 [[link.data [opcode.do_branch_bool reg]] put_goto jfalse put_goto jtrue]
    return 0
}

def emit_while(form out) {
    let jredo put_jump out
    let jtrue put_jump out
    let jfalse put_jump out
    set out 0 cat get out 0 [put_label jredo]
    emit_branch_alike get form 1 jfalse jtrue out
    set out 0 cat get out 0 [put_label jtrue]
    emit_to get form 2 out
    emit_branch_alike get form 1 jfalse jtrue out
    set out 0 cat get out 0 [put_label jfalse]
    return 0
}

def emit_if(form out) {
    let jout put_jump out
    let jtrue put_jump out
    let jfalse put_jump out
    emit_branch_alike get form 1 jfalse jtrue out
    let rret put_reg out
    set out 0 cat get out 0 [put_label jtrue]
    let rtrue emit_to get form 2 out
    if neq rtrue 0 {
        set out 0 cat get out 0 [[link.data [opcode.do_store_reg rret rtrue]]]
    }
    set out 0 cat get out 0 [[link.data [opcode.do_jump]] put_goto jout put_label jfalse]
    let rfalse emit_to get form 3 out
    if neq rfalse 0 {
        set out 0 cat get out 0 [[link.data [opcode.do_store_reg rret rfalse]]]
    }
    set out 0 cat get out 0 [put_label jout]
    return rret
}

def emit_array(form out) {
    let regs empty
    let i 1
    while lt i length form {
        let regs cat regs [emit_to get form i out]
        let i add i 1
    }
    let ret put_reg out
    set out 0 cat get out 0 [[link.data cat [opcode.do_static_array_new ret length regs] regs]]
    return ret
}

def emit_static_array(form out) {
    let regs empty
    let i 1
    while lt i length form {
        let regs cat regs [emit_to get form i out]
        let i add i 1
    }
    let ret put_reg out
    set out 0 cat get out 0 [[link.data cat [opcode.do_static_array_new ret length regs] regs]]
    return ret
}

def emit_str(form out) {
    let ret put_reg out
    set out 0 cat get out 0 [[link.data cat [opcode.do_string_new ret length get form 1] get form 1]]
    return ret
}

def emit_dump(form out) {
    let r1 emit_to get form 1 out
    let r2 emit_to get form 2 out
    set out 0 cat get out 0 [[link.data [opcode.do_dump r1 r2]]]
    return 0
}

def emit_write(form out) {
    let r1 emit_to get form 1 out
    let r2 emit_to get form 2 out
    set out 0 cat get out 0 [[link.data [opcode.do_write r1 r2]]]
    return 0
}

def emit_read(form out) {
    let r1 emit_to get form 1 out
    let ret put_reg out
    set out 0 cat get out 0 [[link.data [opcode.do_read ret r1]]]
    return ret
}

def emit_to(form out) {
    let ty get form 0
    if eq ty vm.ast.num {
        return emit_num form out
    }
    if eq ty vm.ast.index {
        return emit_binop opcode.do_index_get get form 1 get form 2 out
    }
    if eq ty vm.ast.def {
        if gt length get out 0 50 {
            set out 4 cat get out 4 get out 0
            set out 0 empty
        }
        return emit_def form out
    }
    if eq ty vm.ast.return {
        return emit_return form out
    }
    if eq ty vm.ast.exit {
        return emit_exit form out
    }
    if eq ty vm.ast.call {
        return emit_call form out
    }
    if eq ty vm.ast.ident {
        return emit_ident form out
    }
    if eq ty vm.ast.putchar {
        return emit_putchar form out
    }
    if eq ty vm.ast.length {
        return emit_length form out
    }
    if eq ty vm.ast.dump {
        return emit_dump form out
    }
    if eq ty vm.ast.read {
        return emit_read form out
    }
    if eq ty vm.ast.write {
        return emit_write form out
    }
    if eq ty vm.ast.static_array {
        return emit_static_array form out
    }
    if eq ty vm.ast.str {
        return emit_str form out
    }
    if eq ty vm.ast.while {
        return emit_while form out
    }
    if eq ty vm.ast.if {
        return emit_if form out
    }
    if eq ty vm.ast.do {
        return emit_do form out
    }
    if eq ty vm.ast.op {
        let op get get form 1 0
        if eq op '=' {
            return emit_set get form 2 get form 3 out
        }
        if eq op '~' {
            return emit_binop opcode.do_static_concat get form 2 get form 3 out
        }
        if eq op '+' {
            return emit_binop opcode.do_add get form 2 get form 3 out
        }
        if eq op '-' {
            return emit_binop opcode.do_sub get form 2 get form 3 out
        }
        if eq op '*' {
            return emit_binop opcode.do_mul get form 2 get form 3 out
        }
        if eq op '/' {
            return emit_binop opcode.do_div get form 2 get form 3 out
        }
        if eq op '%' {
            return emit_binop opcode.do_mod get form 2 get form 3 out
        }
        puts "emit: form: unknown op"
        exit
    }
    puts "emit: form: unknown form"
    exit
}

def emit(form path) {
    let out [empty 0 ["args" 0] 0 empty empty]
    let form pass_macro_resolve form [empty]
    emit_to form out
    let objcode cat get out 4 cat get out 0 [[link.data [opcode.do_exit]]]
    let linked vm_link objcode
    return linked
}

## paka

def paka_tokenize_stream1(bsrc) {
    let first stream_peek bsrc
    if eq first ' ' {
        stream_skip1 bsrc
        return paka_tokenize_stream1 bsrc
    }
    if eq first 10 {
        stream_skip1 bsrc
        return paka_tokenize_stream1 bsrc
    }
    if eq first 13 {
        stream_skip1 bsrc
        return paka_tokenize_stream1 bsrc
    }
    if eq first '#' {
        stream_skip1 bsrc
        while 1 {
            let cur stream_read  bsrc
            if eq cur 10 {
                return paka_tokenize_stream1 bsrc
            }
            if eq cur 13 {
                return paka_tokenize_stream1 bsrc
            }
        }
    }
    if eq first '(' {
        stream_skip1 bsrc
        return [token.open.paren]
    }
    if eq first ')' {
        stream_skip1 bsrc
        return [token.close.paren]
    }
    if eq first '{' {
        stream_skip1 bsrc
        return [token.open.curly]
    }
    if eq first '}' {
        stream_skip1 bsrc
        return [token.close.curly]
    }
    if eq first '[' {
        stream_skip1 bsrc
        return [token.open.square]
    }
    if eq first ']' {
        stream_skip1 bsrc
        return [token.close.square]
    }
    if eq first ''' {
        stream_skip1 bsrc
        let cur stream_read  bsrc
        if eq cur '\\' {
            let cur stream_read  bsrc
            if neq stream_read bsrc ''' {
                puts "unterminated char literal"
                exit
            }
            if eq cur 'n' {
                return [token.num 10]
            } 
            if eq cur 'r' {
                return [token.num 13]
            } 
            if eq cur 34 {
                return [token.num cur]
            }
            if eq cur '\\' {
                return [token.num cur]
            }
        } else {
            if neq stream_read bsrc ''' {
                puts "unterminated char literal"
                exit
            }
            return [token.num cur]
        }
    }
    if eq first 34 {
        stream_skip1 bsrc
        let ret empty
        while 1 {
            let cur stream_read  bsrc
            if eq cur 0 {
                puts "eof in str"
                exit
            }
            if eq cur 34 {
                return [token.str ret]
            }
            if eq cur '\\' {
                let cur stream_read  bsrc
                if eq cur 'n' {
                    let ret push ret 10
                } 
                if eq cur 34 {
                    let ret cat ret "\""
                }
                if eq cur '\\' {
                    let ret cat ret "\\"
                }
            } else {
                let ret push ret cur
            }
        }
    }
    if char_isdigit first {
        let n 0
        while char_isdigit stream_peek bsrc {
            let n add mul n 10 sub stream_read  bsrc '0'
        }
        return [token.num n]
    }
    if char_id first {
        let xsrc empty
        while 1 {
            if char_id stream_peek bsrc {
                let xsrc push xsrc stream_read  bsrc
            } else {
                let n0 get xsrc 0
                if eq n0 'w' {
                    if str.eq xsrc "while" {
                        return [token.keyword.while]
                    }
                    return [token.ident xsrc]
                }
                if eq n0 'i' {
                    if str.eq xsrc "if" {
                        return [token.keyword.if]
                    }
                    return [token.ident xsrc]
                }
                if eq n0 'e' {
                    if str.eq xsrc "else" {
                        return [token.keyword.else]
                    }
                    if str.eq xsrc "exit" {
                        return [token.keyword.exit]
                    }
                    return [token.ident xsrc]
                }
                if eq n0 'd' {
                    if str.eq xsrc "def" {
                        return [token.keyword.def]
                    }
                    return [token.ident xsrc]
                }
                if eq n0 'r' {
                    if str.eq xsrc "return" {
                        return [token.keyword.return]
                    }
                    return [token.ident xsrc]
                }
                if eq n0 'm' {
                    if str.eq xsrc "macro" {
                        return [token.keyword.macro]
                    }
                    return [token.ident xsrc]
                }
                return [token.ident xsrc]
            }
        }
    }
    if eq first 0 {
        return empty
    }
    put "bad char: code "
    putn first
    putchar 10
    exit
}

def token_stream_new(src) {
    return [[src 0] empty]
}

def token_stream_read(tokens) {
    let ret token_stream_peek tokens
    token_stream_skip1 tokens
    return ret
}

def token_stream_peek(tokens) {
    if eq length get tokens 1 0 {
        set tokens 1 paka_tokenize_stream1 get tokens 0
    }
    return get tokens 1
}

def token_stream_skip1(tokens) {
    if eq length get tokens 1 0 {
        paka_tokenize_stream1 get tokens 0
    }
    set tokens 1 empty
}

def paka_read_scall(tokens nargs args state) {
    let target add nargs length args
    let got token_stream_peek tokens
    if eq get got 0  token.open.paren {
        token_stream_skip1 tokens
        while 1 {
            let cur token_stream_peek tokens
            if eq length cur 0 {
                puts "error eof arg"
                exit
            }
            if eq get cur 0 token.close.paren {
                token_stream_skip1 tokens
                if neq length args target {
                    puts "error: argc"
                    exit
                }
                return paka_read_post tokens args state
            }
            let arg paka_read_expr_base tokens state
            let args push args arg
        }
    }
    while lt length args target {
        let cur token_stream_peek tokens
        if eq length cur 0 {
            puts "error eof arg"
        }
        let arg paka_read_expr_base tokens state
        let args push args arg
    }
    return paka_read_post tokens args state
}

def paka_read_post(tokens last state) {
    let first token_stream_peek tokens
    if eq length first 0 {
        return last
    }
    if eq get last 0 vm.ast.ident {
        let found findvar state get last 1
        if eq length found 1 {
            let args [vm.ast.call last] 
            return paka_read_scall tokens get found 0 args state
        }
    }
    return last
}

def paka_read_single(tokens state) {
    let first token_stream_peek tokens
    if eq length first 0 {
        return 0
    }
    if eq get first 0 token.open.square {
        token_stream_skip1 tokens
        let args [vm.ast.static_array]
        while 1 {
            let cur token_stream_peek tokens
            if eq get cur 0 token.close.square {
                token_stream_skip1 tokens
                return args
            }
            let expr paka_read_expr_base tokens state
            let args push args expr
        } 
    }
    if eq get first 0 token.open.paren {
        token_stream_skip1 tokens
        let ret paka_read_expr_base tokens state
        token_stream_skip1 tokens
        return ret
    }
    if eq get first 0 token.num {
        token_stream_skip1 tokens
        return [vm.ast.num get first 1]
    }
    if eq get first 0 token.str {
        token_stream_skip1 tokens
        return [vm.ast.str get first 1]
    }
    if eq get first 0 token.ident {
        token_stream_skip1 tokens
        if str.eq get first 1 "putchar" {
            return paka_read_scall tokens 1 [vm.ast.putchar] state
        } 
        if str.eq get first 1 "length" {
            return paka_read_scall tokens 1 [vm.ast.length] state
        }
        if str.eq get first 1 "dump" {
            return paka_read_scall tokens 2 [vm.ast.dump] state
        }
        if str.eq get first 1 "write" {
            return paka_read_scall tokens 2 [vm.ast.write] state
        }
        if str.eq get first 1 "read" {
            return paka_read_scall tokens 1 [vm.ast.read] state
        }
        if str.eq get first 1 "get" {
            return paka_read_scall tokens 2 [vm.ast.index] state
        }
        if str.eq get first 1 "set" {
            let args paka_read_scall tokens 3 empty state
            return [vm.ast.op "=" [vm.ast.index get args 0 get args 1] get args 2]
        }
        if str.eq get first 1 "do" {
            return paka_read_scall tokens 2 [vm.ast.do] state
        }
        if str.eq get first 1 "+" {
            return paka_read_scall tokens 2 [vm.ast.op "+"] state
        }
        if str.eq get first 1 "-" {
            return paka_read_scall tokens 2 [vm.ast.op "-"] state
        }
        if str.eq get first 1 "*" {
            return paka_read_scall tokens 2 [vm.ast.op "*"] state
        }
        if str.eq get first 1 "/" {
            return paka_read_scall tokens 2 [vm.ast.op "/"] state
        }
        if str.eq get first 1 "%" {
            return paka_read_scall tokens 2 [vm.ast.op "%"] state
        }
        if str.eq get first 1 "<" {
            return paka_read_scall tokens 2 [vm.ast.op "<"] state
        }
        if str.eq get first 1 ">" {
            return paka_read_scall tokens 2 [vm.ast.op ">"] state
        }
        if str.eq get first 1 "<=" {
            return paka_read_scall tokens 2 [vm.ast.op "<="] state
        }
        if str.eq get first 1 ">=" {
            return paka_read_scall tokens 2 [vm.ast.op ">="] state
        }
        if str.eq get first 1 "==" {
            return paka_read_scall tokens 2 [vm.ast.op "=="] state
        }
        if str.eq get first 1 "!=" {
            return paka_read_scall tokens 2 [vm.ast.op "!="] state
        }
        if str.eq get first 1 "add" {
            return paka_read_scall tokens 2 [vm.ast.op "+"] state
        }
        if str.eq get first 1 "sub" {
            return paka_read_scall tokens 2 [vm.ast.op "-"] state
        }
        if str.eq get first 1 "mul" {
            return paka_read_scall tokens 2 [vm.ast.op "*"] state
        }
        if str.eq get first 1 "div" {
            return paka_read_scall tokens 2 [vm.ast.op "/"] state
        }
        if str.eq get first 1 "mod" {
            return paka_read_scall tokens 2 [vm.ast.op "%"] state
        }
        if str.eq get first 1 "cat" {
            return paka_read_scall tokens 2 [vm.ast.op "~"] state
        }
        if str.eq get first 1 "lt" {
            return paka_read_scall tokens 2 [vm.ast.op "<"] state
        }
        if str.eq get first 1 "gt" {
            return paka_read_scall tokens 2 [vm.ast.op ">"] state
        }
        if str.eq get first 1 "lte" {
            return paka_read_scall tokens 2 [vm.ast.op "<="] state
        }
        if str.eq get first 1 "gte" {
            return paka_read_scall tokens 2 [vm.ast.op ">="] state
        }
        if str.eq get first 1 "eq" {
            return paka_read_scall tokens 2 [vm.ast.op "=="] state
        }
        if str.eq get first 1 "neq" {
            return paka_read_scall tokens 2 [vm.ast.op "!="] state
        }
        if str.eq get first 1 "let" {
            return paka_read_scall tokens 2 [vm.ast.op "="] state
        }
        if str.eq get first 1 "cond" {
            return paka_read_scall tokens 3 [vm.ast.if] state
        }
        return [vm.ast.ident get first 1]
    }
    put "error: unexpected token#"
    putn get first 0
    puts "."
    exit
}

def parse_is_not_in(op some) {
    let i 0
    while lt i length some {
        if str.eq op get some i {
            return 0
        }
        let i add i 1
    }
    return 1
}

def paka_read_expr_base(tokens state) {
    return paka_read_post tokens paka_read_single tokens state state
}

def paka_read_stmt(tokens state) {
    let first token_stream_peek tokens
    if eq get first 0 token.keyword.def {
        token_stream_skip1 tokens
        let expr paka_read_expr_base tokens state
        let block paka_read_block tokens state
        return [vm.ast.def expr block]
    }
    if eq get first 0 token.keyword.macro {
        token_stream_skip1 tokens
        let name token_stream_read tokens
        let first token_stream_peek tokens
        let block paka_read_block tokens state
        return [vm.ast.enum [vm.ast.ident get name 1] block]
    }
    if eq get first 0 token.keyword.exit {
        token_stream_skip1 tokens
        return [vm.ast.exit]
    }
    if eq get first 0 token.keyword.if {
        token_stream_skip1 tokens
        let expr paka_read_expr_base tokens state
        let block1 paka_read_block tokens state
        let block2 [vm.ast.do]
        let first token_stream_peek tokens
        if eq get first 0 token.keyword.else {
            token_stream_skip1 tokens
            let block2 paka_read_block tokens state
        }
        return [vm.ast.if expr block1 block2]
    }
    if eq get first 0 token.keyword.return {
        token_stream_skip1 tokens
        let expr paka_read_expr_base tokens state
        return [vm.ast.return expr]
    }
    if eq get first 0 token.keyword.while {
        token_stream_skip1 tokens
        let expr paka_read_expr_base tokens state
        let block paka_read_block tokens state
        return [vm.ast.while expr block]
    }
    let ret paka_read_expr_base tokens state
    return ret
}

def paka_read_block_body(tokens state) {
    let ret [vm.ast.do]
    while 1 {
        let first token_stream_peek tokens
        if eq length first 0 {
            return ret
        }
        if eq get first 0 token.close.curly {
            return ret
        }
        let stmt paka_read_stmt tokens state
        let ret push ret stmt
    }
}

def paka_read_block(tokens state) {
    let first token_stream_peek tokens
    if eq get first 0 token.open.curly {
        token_stream_skip1 tokens
        let ret paka_read_block_body tokens state
        token_stream_skip1 tokens
        return ret
    }
    return [vm.ast.do paka_read_stmt tokens state]
}

def paka_read_nargs(tokens name state) {
    let got token_stream_peek tokens
    if eq get got 0  token.open.paren {
        token_stream_skip1 tokens
        let n 0
        while 1 {
            let cur token_stream_peek tokens
            if eq length cur 0 {
                puts "error: need `)` after args to def"
                exit
            }
            if eq get cur 0 token.close.paren {
                token_stream_skip1 tokens
                return n
            }
            paka_read_expr_base tokens state
            let n add n 1
        }
    } else {
        let n 0
        while 1 {
            let cur token_stream_peek tokens
            if eq length cur 0 {
                puts "error: need `:` after def"
            }
            if eq get cur 0 token.op {
                if str.eq get cur 1 ":" {
                    token_stream_skip1 tokens
                    return n
                }
            }
            paka_read_expr_base tokens state
            let n add n 1
        }
    }
}

def paka_build_defs(tokens) {
    let ret empty
    while 1 {
        let first token_stream_read tokens
        if eq get first 0 token.keyword.def {
            let name token_stream_read tokens
            let argc paka_read_nargs tokens get name 1 empty
            let ret cat ret [get name 1 argc]
        }
        if eq length first 0 {
            return ret
        }
    }
}

def paka_parse(src) {
    return paka_read_block_body token_stream_new src paka_build_defs token_stream_new src
}

## main

def main(argv) {
    let outfile "exec.bc"
    let srcfile ""
    let i 0
    while lt i length argv {
        let arg get argv i 
        if eq get arg 0 '-' {
            if eq get arg 1 'o' {
                let i add i 1
                let outfile get argv i
            }
        } else {
            if neq length srcfile 0 {
                puts "only one source can be provided"
                exit
            }
            let srcfile arg
        }
        let i add i 1
    }
    if eq length srcfile 0 {
        puts "no sources provided"
        exit
    }
    let src read srcfile
    if eq length src 0 {
        puts "cannot read file"
        exit
    }
    let ast paka_parse src
    let bc emit ast srcfile
    dump outfile bc
}

main args
return 0
