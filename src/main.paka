
## io

def put(str) {
    i = 0
    while i < length(str) {
        putchar(str[i])
        i = i + 1
    }
}

def puts(str) {
    put(str)
    putchar(10)
}

def putn_gte0(n) {
    if n >= 10 {
        lowest = n % 10
        putn_gte0((n - lowest) / 10)
        putchar(lowest + 48)
    } else {
        putchar(n % 10 + 48)
    }
}

def putn(n) {
    if n < 0 {
        put("-")
        putn_gte0(0 - n)
    } else {
        putn_gte0(n)
    }
}

## strings

def char_between(chr, pair) {
    if pair[0] <= chr {
        if chr <= pair[1] {
            return 1
        }
    }
    return 0
}
 
def char_isdigit(chr) {
    if char_between(chr, "09") {
        return 1
    } else {
        return 0
    }
}

def char_isalpha(chr) {
    if char_between(chr, "az") {
        return 1
    }
    if char_between(chr, "AZ") {
        return 1
    }
    return 0
}

def char_id0(chr) {
    if char_isalpha(chr) {
        return 1
    }
    if chr == '.' {
        return 1
    }
    if chr == '_' {
        return 1
    }
    return 0
}

def char_id(chr) {
    if char_id0(chr) {
        return 1
    }
    if char_isdigit(chr) {
        return 1
    }
    return 0
}

def str_starts_with(src, items) {
    if length(items) > length(src) {
        return 0
    }
    i = 0
    while i < length(items) {
        if items[i] != src[i] {
            return 0
        }
        i = i + 1
    }
    return 1
}

def str.eq(sa, sb) {
    len = length(sa)
    if length(sa) != length(sb) {
        return 0
    }
    i = 0
    while i < len {
        if sa[i] != sb[i] {
            return 0
        }
        i = i + 1
    }
    return 1
}

## char streams

def stream_new(src) {
    return [src, 0]
}

def stream_peek(src) {
    if src[1] < length(src[0]) {
        return src[0][src[1]]
    } else {
        return 0
    }
}

def stream_skip1(src) {
    if src[1] < length(src[0]) {

        src[1] = src[1] + 1
    }
}

def stream_skip(src, n) {
    i = 0
    while i < n {
        stream_skip1(src)
        i = i + 1
    }
}

def stream_read(src) {
    ret = stream_peek(src)
    stream_skip1(src)
    return ret
}

def stream_starts_swith(src, items) {
    if length(items) + src[1] > length(src[0]) {
        return 0
    }
    i = 0
    while i < length(items) {
        if items[i] != src[0][src[1] + i] {
            return 0
        }
        i = i + 1
    }
    return 1
}

## linker

macro link {
    data = 0
    jump = 1
    label = 2
    call = 3
    func = 4
}

def vm_link(bc) {
    nops = 0
    func_locs = []
    sized0 = []
    sized1 = []
    labels = []
    i = 0
    while i < length(bc) {
        cur = bc[i]
        if cur[0] == link.func {
            func_locs = func_locs ~ [cur[1], nops]
        }
        if cur[0] == link.label {
            labels = labels ~ [cur[1], nops]
        }
        if cur[0] == link.call {
            sized0 = sized0 ~ [cur]
            nops = nops + 1
        }
        if cur[0] == link.jump {
            sized0 = sized0 ~ [cur]
            nops = nops + 1
        }
        if cur[0] == link.data {
            sized0 = sized0 ~ [cur]
            nops = nops + length(cur[1])
        }
        if length(sized0) >= 50 {
            sized1 = sized1 ~ sized0
            sized0 = []
        }
        i = i + 1
    }
    sized = sized1 ~ sized0
    ops0 = []
    ops1 = []
    ops2 = []
    ops3 = []
    ops4 = []
    i = 0
    while i < length(sized) {
        op = sized[i]
        if op[0] == link.data {
            ops0 = ops0 ~ op[1]
            if length(ops0) >= 30 {
                ops1 = ops1 ~ ops0
                ops0 = []
                if length(ops1) > 90 {
                    ops2 = ops2 ~ ops1
                    ops1 = []
                    if length(ops2) > 300 {
                        ops3 = ops3 ~ ops2
                        ops2 = []
                    }
                }
            }
        }
        if op[0] == link.jump {
            found = findvar.ikey(labels, op[1])
            if length(found) == 0 {
                puts("cannot jump to undefined label")
                exit
            }
            ops0 = ops0 ~ found
        }
        if op[0] == link.call {
            func = findvar(func_locs, op[1])
            if length(func) == 0 {
                put("link error: undefined: ")
                puts(op[1])
                exit
            }
            ops0 = ops0 ~ [func[0]]
        }
        i = i + 1
    }
    return ops3 ~ (ops2 ~ (ops1 ~ ops0))
}

## opcodes

macro vm {
    ast.num
    ast.index
    ast.def
    ast.return
    ast.defer
    ast.enum
    ast.when
    ast.exit
    ast.call
    ast.ident
    ast.length
    ast.import
    ast.dump
    ast.read
    ast.write
    ast.str
    ast.while
    ast.if
    ast.do
    ast.attrs
    ast.putchar
    ast.value_key
    ast.static_array
    ast.op
}

macro token {
    open.paren
    open.square
    open.curly
    close.paren
    close.square
    close.curly
    colon
    comma
    keyword.while
    keyword.if
    keyword.else
    keyword.def
    keyword.return
    keyword.defer
    keyword.macro
    keyword.exit
    op
    str
    num
    ident
}

macro opcode {
    do_exit = 0
    do_store_reg = 1
    do_branch_bool = 2
    do_store_int = 3
    do_jump = 4
    do_func = 5
    do_add = 6
    do_sub = 7
    do_mul = 8
    do_div = 9
    do_mod = 10
    do_branch_less_than_equal = 11
    do_static_call = 12
    do_return = 13
    do_putchar = 14
    do_string_new = 15
    do_length = 16
    do_index_get = 17
    do_index_set = 18
    do_dump = 19
    do_read = 20
    do_write = 21
    do_static_array_new = 22
    do_static_concat = 23
    do_branch_equal = 24
    do_branch_less = 25
}

## find variables

def findvar(vars, name) {
    i = 0
    while i < length(vars) {
        k = vars[i]
        i = i + 1
        v = vars[i]
        i = i + 1
        if str.eq(k, name) {
            return [v]
        }
    }
    return []
}

def findvar.ikey(vars, name) {
    i = 0
    while i < length(vars) {
        k = vars[i]
        i = i + 1
        v = vars[i]
        i = i + 1
        if k == name {
            return [v]
        }
    }
    return []
}

## macro resolver

def pass_macro_resolve_copy(form, state) {
    ret = [form[0]]
    i = 1
    while i < length(form) {
        ret = ret ~ [pass_macro_resolve(form[i], state)]
        i = i + 1
    }
    return ret
}

def pass_macro_resolve_enum(form, state) {
    name = form[1][1]
    idents = []
    where = 1
    while where < length(form[2]) {
        ok = 0
        if form[2][where][0] == vm.ast.ident {
            fullname = form[1][1] ~ ['.'] ~ form[2][where][1]
            ast = [vm.ast.num, where]
            state[0] = state[0] ~ [fullname, ast]
            ok = 1
        }
        if form[2][where][0] == vm.ast.op {
            if str.eq(form[2][where][1], "=") {
                setto = form[2][where][2]
                val = form[2][where][3]
                if setto[0] != vm.ast.ident {
                    puts("enum macro given bad value on left hand size of `=`")
                    exit
                }
                fullname = form[1][1] ~ ['.'] ~ setto[1]
                state[0] = state[0] ~ [fullname, val]
                ok = 1
            }
        }
        if ok == 0 {
            puts("that is not valid in a macro")
            exit
        }
        where = where + 1
    }
    return [vm.ast.do]
}
 
def pass_macro_resolve(form, state) {
    ty = form[0]
    if ty == vm.ast.num {
        return form
    }
    if ty == vm.ast.str {
        return form
    }
    if ty == vm.ast.attrs {
        return form
    }
    if ty == vm.ast.ident {
        val = findvar(state[0], form[1])
        if length(val) != 0 {
            return val[0]
        }
        return form
    }
    if ty == vm.ast.op {
        return [ty, form[1], pass_macro_resolve(form[2], state), pass_macro_resolve(form[3], state)]
    }
    if ty == vm.ast.enum {
        return pass_macro_resolve_enum(form, state)
    }
    if ty == vm.ast.def {
        return pass_macro_resolve_copy(form, state)
    }
    return pass_macro_resolve_copy(form, state)
}

## emit

def put_reg(out) {
    out[1] = out[1] + 1
    return out[1]
}
def emit_num(form, out) {
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_int, ret, form[1]]]]
    return ret
}

def emit_binop(op, form1, form2, out) {
    r1 = emit_to(form1, out)
    r2 = emit_to(form2, out)
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [op, ret, r1, r2]]]
    return ret
}

def emit_putchar(form, out) {
    r1 = emit_to(form[1], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_putchar, r1]]]
    return 0
}

def emit_length(form, out) {
    r1 = emit_to(form[1], out)
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_length, ret, r1]]]
    return ret
}

def emit_do(form, out) {
    old5 = out[5]
    out[5] = [[]] ~ old5
    ret = 0
    i = 1
    while i < length(form) {
        ret = emit_to(form[i], out)
        i = i + 1
    } 
    ent = 0
    while ent < length(out[5][0]) {
        cur = emit_to(out[5][0][ent], out)
        if cur != 0 {
            ret = cur
        }
        ent = ent + 1
    }
    out[5] = old5
    return ret
}

def emit_ident(form, out) {
    res = findvar(out[2], form[1])
    if length(res) == 0 {
        i = 0
        while i < length(out[2]) {
            puts("did you mean: " ~ out[2][i])
            i = i + 2
        }
        puts("unknown ident: " ~ form[1])
        exit
    }
    return res[0]
}

def emit_set(from, to, out) {
    if from[0] == vm.ast.ident {
        found = findvar(out[2], from[1])
        if length(found) == 0 {
            varreg = emit_to(to, out)
            to = put_reg(out)
            out[2] = out[2] ~ [from[1], to]
            out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, to, varreg]]]
            return to
        } else {
            from = emit_to(to, out)
            out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, found[0], from]]]
            return found[0]
        }
    }
    if from[0] == vm.ast.index {
        array = emit_to(from[1], out)
        index = emit_to(from[2], out)
        varreg = emit_to(to, out)
        out[0] = out[0] ~ [[link.data, [opcode.do_index_set, array, index, varreg]]]
        return array
    }
    put("cannot set to: ")
    exit
}

def put_jump(out) {
    count = out[3]
    out[3] = out[3] + 1
    return count
}

def put_goto(jump) {
    return [link.jump, jump] 
}

def put_label(jump) {
    return [link.label, jump]
}

def emit_def(form, out) {
    jover = put_jump(out)
    call = form[1]
    body = form[2]
    tmp1 = out[1]
    tmp2 = out[2]
    tmp5 = out[5]
    out[2] = []
    out[5] = []
    i = 2
    while i < length(call) {
        out[2] = out[2] ~ [call[i][1], i - 1]
        i = i + 1
    }
    out[1] = i - 1
    nregs = [link.data, [256]]
    out[0] = out[0] ~ [[link.data, [opcode.do_func]], put_goto(jover), nregs, [link.func, call[1][1]]]
    resreg = emit_to(body, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_return, resreg]]]
    nregs[1][0] = out[1]
    out[1] = tmp1
    out[2] = tmp2
    out[5] = tmp5
    out[0] = out[0] ~ [put_label(jover)]
    return 0
}

def emit_return(form, out) {
    rreg = emit_to(form[1], out)
    lvl = 0
    while lvl < length(out[5]) {
        ent = 0
        while ent < length(out[5][lvl]) {
            emit_to(out[5][lvl][ent], out)
            ent = ent + 1
        }
        lvl = lvl + 1
    }
    out[0] = out[0] ~ [[link.data, [opcode.do_return, rreg]]]
    return 0
}

def emit_defer(form, out) {
    if length(out[5]) == 0 {
        puts("defer invalid in that location")
        exit
    }
    out[5][0] = [form[1]] ~ out[5][0]
    return 0
}

def emit_exit(form, out) {
    out[0] = out[0] ~ [[link.data, [opcode.do_exit]]]
    return 0
}

def emit_call(form, out) {
    if form[1][0] == vm.ast.ident {
        args = []
        i = 2
        while i < length(form) {
            args = args ~ [emit_to(form[i], out)]
            i = i + 1
        } 
        ret = put_reg(out)
        out[0] = out[0] ~ [[link.data, [opcode.do_static_call, ret]], [link.call, form[1][1]], [link.data, [length(args)] ~ args]]
        return ret
    } else {
        puts("no dynamic calls yet")
        exit
    }
}

def emit_branch_alike(cond, jfalse, jtrue, out) {
    if cond[0] == vm.ast.op {
        first = cond[1][0]
        if str.eq(cond[1], ">") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, rhs, lhs]], put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], "<=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal, lhs, rhs]], put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], "==") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal, lhs, rhs]], put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], "!=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_equal, lhs, rhs]], put_goto(jtrue), put_goto(jfalse)]
            return 0
        }
        if str.eq(cond[1], "<") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less, lhs, rhs]], put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
        if str.eq(cond[1], ">=") {
            lhs = emit_to(cond[2], out)
            rhs = emit_to(cond[3], out)
            out[0] = out[0] ~ [[link.data, [opcode.do_branch_less_than_equal, rhs, lhs]], put_goto(jfalse), put_goto(jtrue)]
            return 0
        }
    }
    reg = emit_to(cond, out)
    out[0] = out[0] ~ [[link.data, [opcode.do_branch_bool, reg]], put_goto(jfalse), put_goto(jtrue)]
    return 0
}

def emit_while(form, out) {
    jredo = put_jump(out)
    jtrue = put_jump(out)
    jfalse = put_jump(out)
    out[0] = out[0] ~ [put_label(jredo)]
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [put_label(jtrue)]
    emit_to(form[2], out)
    emit_branch_alike(form[1], jfalse, jtrue, out)
    out[0] = out[0] ~ [put_label(jfalse)]
    return 0
}

def emit_if(form, out) {
    jout = put_jump(out)
    jtrue = put_jump(out)
    jfalse = put_jump(out)
    emit_branch_alike(form[1], jfalse, jtrue, out)
    rret = put_reg(out)
    out[0] = out[0] ~ [put_label(jtrue)]
    rtrue = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, rret, rtrue, opcode.do_jump]], put_goto(jout), put_label(jfalse)]
    rfalse = emit_to(form[3], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_store_reg, rret, rfalse]]]
    out[0] = out[0] ~ [put_label(jout)]
    return rret
}

def emit_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_static_array(form, out) {
    regs = []
    i = 1
    while i < length(form) {
        regs = regs ~ [emit_to(form[i], out)]
        i = i + 1
    }
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_static_array_new, ret, length(regs)] ~ regs]]
    return ret
}

def emit_str(form, out) {
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_string_new, ret, length(form[1])] ~ form[1]]]
    return ret
}

def emit_dump(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_dump, r1, r2]]]
    return 0
}

def emit_write(form, out) {
    r1 = emit_to(form[1], out)
    r2 = emit_to(form[2], out)
    out[0] = out[0] ~ [[link.data, [opcode.do_write, r1, r2]]]
    return 0
}

def emit_read(form, out) {
    r1 = emit_to(form[1], out)
    ret = put_reg(out)
    out[0] = out[0] ~ [[link.data, [opcode.do_read, ret, r1]]]
    return ret
}

def emit_to(form, out) {
    ty = form[0]
    if ty == vm.ast.num {
        return emit_num(form, out)
    }
    if ty == vm.ast.index {
        return emit_binop(opcode.do_index_get, form[1], form[2], out)
    }
    if ty == vm.ast.def {
        if length(out[0]) > 50 {
            out[4] = out[4] ~ out[0]
            out[0] = []
        }
        return emit_def(form, out)
    }
    if ty == vm.ast.defer {
        return emit_defer(form, out)
    }
    if ty == vm.ast.return {
        return emit_return(form, out)
    }
    if ty == vm.ast.exit {
        return emit_exit(form, out)
    }
    if ty == vm.ast.call {
        return emit_call(form, out)
    }
    if ty == vm.ast.ident {
        return emit_ident(form, out)
    }
    if ty == vm.ast.putchar {
        return emit_putchar(form, out)
    }
    if ty == vm.ast.length {
        return emit_length(form, out)
    }
    if ty == vm.ast.dump {
        return emit_dump(form, out)
    }
    if ty == vm.ast.read {
        return emit_read(form, out)
    }
    if ty == vm.ast.write {
        return emit_write(form, out)
    }
    if ty == vm.ast.static_array {
        return emit_static_array(form, out)
    }
    if ty == vm.ast.str {
        return emit_str(form, out)
    }
    if ty == vm.ast.while {
        return emit_while(form, out)
    }
    if ty == vm.ast.if {
        return emit_if(form, out)
    }
    if ty == vm.ast.do {
        return emit_do(form, out)
    }
    if ty == vm.ast.op {
        op = form[1][0]
        if op == '=' {
            return emit_set(form[2], form[3], out)
        }
        if op == '~' {
            return emit_binop(opcode.do_static_concat, form[2], form[3], out)
        }
        if op == '+' {
            return emit_binop(opcode.do_add, form[2], form[3], out)
        }
        if op == '-' {
            return emit_binop(opcode.do_sub, form[2], form[3], out)
        }
        if op == '*' {
            return emit_binop(opcode.do_mul, form[2], form[3], out)
        }
        if op == '/' {
            return emit_binop(opcode.do_div, form[2], form[3], out)
        }
        if op == '%' {
            return emit_binop(opcode.do_mod, form[2], form[3], out)
        }
        puts("emit: form: unknown op")
        exit
    }
    puts("emit: form: unknown form")
    exit
}

def emit(form, path) {
    out = [[], 0, ["args", 0], 0, [], []]
    form = pass_macro_resolve(form, [[]])
    emit_to(form, out)
    objc = out[4] ~ out[0] ~ [[link.data, [opcode.do_exit]]]
    linked = vm_link(objc)
    return linked
}

## paka

def paka_tokenize_stream1(bsrc, ops_flat) {
    first = stream_peek(bsrc)
    if first == ' ' {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if first == 10 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if first == 13 {
        stream_skip1(bsrc)
        return paka_tokenize_stream1(bsrc, ops_flat)
    }
    if first == '#' {
        stream_skip1(bsrc)
        while 1 {
            cur = stream_read(bsrc)
            if cur == 10 {
                return paka_tokenize_stream1(bsrc, ops_flat)
            }
            if cur == 13 {
                return paka_tokenize_stream1(bsrc, ops_flat)
            }
        }
    }
    if first == '(' {
        stream_skip1(bsrc)
        return [token.open.paren]
    }
    if first == ')' {
        stream_skip1(bsrc)
        return [token.close.paren]
    }
    if first == '{' {
        stream_skip1(bsrc)
        return [token.open.curly]
    }
    if first == '}' {
        stream_skip1(bsrc)
        return [token.close.curly]
    }
    if first == '[' {
        stream_skip1(bsrc)
        return [token.open.square]
    }
    if first == ']' {
        stream_skip1(bsrc)
        return [token.close.square]
    }
    if first == ',' {
        stream_skip1(bsrc)
        return [token.comma]
    }
    if first == ''' {
        stream_skip1(bsrc)
        cur = stream_read(bsrc)
        if cur == "\\"[0] {
            cur = stream_read(bsrc)
            if stream_read(bsrc) != ''' {
                puts("unterminated char literal")
                exit
            }
            if cur == 'n' {
                return [token.num, 10]
            } 
            if cur == 'r' {
                return [token.num, 13]
            } 
            if cur == "\""[0] {
                return [token.num, cur]
            }
            if cur == "\\"[0] {
                return [token.num, cur]
            }
        } else {
            if stream_read(bsrc) != ''' {
                puts("unterminated char literal")
                exit
            }
            return [token.num, cur]
        }
    }
    if first == "\""[0] {
        stream_skip1(bsrc)
        ret = []
        while 1 {
            cur = stream_read(bsrc)
            if cur == 0 {
                puts("eof in str")
                exit
            }
            if cur == "\""[0] {
                return [token.str, ret]
            }
            if cur == "\\"[0] {
                cur = stream_read(bsrc)
                if cur == 'n' {
                    ret = ret ~ [10]
                } 
                if cur == "\""[0] {
                    ret = ret ~ "\""
                }
                if cur == "\\"[0] {
                    ret = ret ~ "\\"
                }
            } else {
                ret = ret ~ [cur]
            }
        }
    }
    i = 0
    while i < length(ops_flat) {
        if stream_starts_swith(bsrc, ops_flat[i]) {
            stream_skip(bsrc, length(ops_flat[i]))
            return [token.op, ops_flat[i]]
        }
        i = i + 1
    }
    if char_isdigit(first) {
        n = 0
        while char_isdigit(stream_peek(bsrc)) {
            n = n * 10 + stream_read(bsrc) - '0'
        }
        return [token.num, n]
    }
    if char_id0(first) {
        xsrc = []
        while 1 {
            if char_id(stream_peek(bsrc)) {
                xsrc = xsrc ~ [stream_read(bsrc)]
            } else {
                n0 = xsrc[0]
                if n0 == 'w' {
                    if str.eq(xsrc, "while") {
                        return [token.keyword.while]
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'i' {
                    if str.eq(xsrc, "if") {
                        return [token.keyword.if]
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'e' {
                    if str.eq(xsrc, "else") {
                        return [token.keyword.else]
                    }
                    if str.eq(xsrc, "exit") {
                        return [token.keyword.exit]
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'd' {
                    if str.eq(xsrc, "def") {
                        return [token.keyword.def]
                    }
                    if str.eq(xsrc, "defer") {
                        return [token.keyword.defer]
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'r' {
                    if str.eq(xsrc, "return") {
                        return [token.keyword.return]
                    }
                    return [token.ident, xsrc]
                }
                if n0 == 'm' {
                    if str.eq(xsrc, "macro") {
                        return [token.keyword.macro]
                    }
                    return [token.ident, xsrc]
                }
                return [token.ident, xsrc]
            }
        }
    }
    if first == 0 {
        return []
    }
    put("bad char: code ")
    putn(first)
    putchar(10)
    exit
}

def token_stream_new(src) {
    ops_flat = ["<=", ">=", "==", "!=", "=", "~", "+", "-", "%", "*", "/", "<", ">", ":", "@"]
    ssrc = [src, 0]
    return [ops_flat, ssrc, []]
}

def token_stream_read(tokens) {
    ret = token_stream_peek(tokens)
    token_stream_skip1(tokens)
    return ret
}

def token_stream_peek(tokens) {
    if length(tokens[2]) == 0 {
        tokens[2] = paka_tokenize_stream1(tokens[1], tokens[0])
    }
    return tokens[2]
}

def token_stream_skip1(tokens) {
    if length(tokens[2]) == 0 {
        paka_tokenize_stream1(tokens[1], tokens[0])
    }
    tokens[2] = []
}

def paka_skip_comma(tokens) {
    first = token_stream_peek(tokens)
    if first[0] == token.comma {
        token_stream_skip1(tokens)
    }
}

def paka_read_scall(tokens, nargs, args, state) {
    target = nargs + length(args)
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error eof arg")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                if length(args) != target {
                    puts("error: argc")
                    exit
                }
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = args ~ [arg]
            paka_skip_comma(tokens)
        }
    }
    while length(args) < target {
        cur = token_stream_peek(tokens)
        if length(cur) == 0 {
            puts("error eof arg")
        }
        arg = paka_read_expr_base(tokens, state)
        args = args ~ [arg]
        paka_skip_comma(tokens)
    }
    return paka_read_post(tokens, args, state)
}

def paka_read_call(tokens, args, state) {
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error 1")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                return paka_read_post(tokens, args, state)
            }
            arg = paka_read_expr_base(tokens, state)
            args = args ~ [arg]
            paka_skip_comma(tokens)
        }
    }
    puts("error: wanted `(`")
    exit
}

def paka_read_post(tokens, last, state) {
    first = token_stream_peek(tokens)
    if length(first) == 0 {
        return last
    }
    if first[0] == token.open.square {
        token_stream_skip1(tokens)
        index = paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return paka_read_post(tokens, [vm.ast.index, last, index], state)
    }
    if first[0] == token.open.paren {
        if last[0] != vm.ast.ident {
            put("cannot call anything but idents: ")
            putn(last[0])
            putchar(10)
            exit
        }
        name = last[1]
        found = findvar(state[1], name)
        if length(found) == 0 {
            args = [vm.ast.call, last] 
            return paka_read_call(tokens, args, state)
        } else {
            args = [vm.ast.call, last] 
            return paka_read_scall(tokens, found[0], args, state)
        }
    }
    if last[0] == vm.ast.ident {
        name = last[1]
        found = findvar(state[1], name)
        if length(found) == 1 {
            args = [vm.ast.call, last] 
            return paka_read_scall(tokens, found[0], args, state)
        }
    }
    return last
}

def paka_read_single(tokens, state) {
    first = token_stream_peek(tokens)
    if length(first) == 0 {
        return 0
    }
    if first[0] == token.open.square {
        token_stream_skip1(tokens)
        args = [vm.ast.static_array]
        while 1 {
            cur = token_stream_peek(tokens)
            if cur[0] == token.close.square {
                token_stream_skip1(tokens)
                return args
            }
            expr = paka_read_expr_base(tokens, state)
            args = args ~ [expr]
            paka_skip_comma(tokens)
        } 
    }
    if first[0] == token.open.paren {
        token_stream_skip1(tokens)
        ret = paka_read_expr_base(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    if first[0] == token.num {
        token_stream_skip1(tokens)
        return [vm.ast.num, first[1]]
    }
    if first[0] == token.str {
        token_stream_skip1(tokens)
        return [vm.ast.str, first[1]]
    }
    if first[0] == token.ident {
        token_stream_skip1(tokens)
        if str.eq(first[1], "putchar") {
            return paka_read_scall(tokens, 1, [vm.ast.putchar], state)
        } 
        if str.eq(first[1], "length") {
            return paka_read_scall(tokens, 1, [vm.ast.length], state)
        }
        if str.eq(first[1], "dump") {
            return paka_read_scall(tokens, 2, [vm.ast.dump], state)
        }
        if str.eq(first[1], "write") {
            return paka_read_scall(tokens, 2, [vm.ast.write], state)
        }
        if str.eq(first[1], "read") {
            return paka_read_scall(tokens, 1, [vm.ast.read], state)
        }
        if str.eq(first[1], "import") {
            return paka_read_scall(tokens, 1, [vm.ast.import], state)
        }
        return [vm.ast.ident, first[1]]
    }
    if first[0] == token.keyword.if {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block1 = paka_read_block(tokens, state)
        block2 = [vm.ast.do]
        first = token_stream_peek(tokens)
        if first[0] == token.keyword.else {
            token_stream_skip1(tokens)
            block2 = paka_read_block(tokens, state)
        }
        return [vm.ast.if, expr, block1, block2]
    }
    put("error: unexpected token#")
    putn(first[0])
    puts(".")
    exit
}

def parse_is_not_in(op, some) {
    i = 0
    while i < length(some) {
        if str.eq(op, some[i]) {
            return 0
        }
        i = i + 1
    }
    return 1
}

def paka_read_expr(tokens, depth, state) {
    ops = state[0]
    if depth >= length(ops) {
        return paka_read_post(tokens, paka_read_single(tokens, state), state)
    }
    ret = paka_read_expr(tokens, depth + 1, state)
    while 1 {
        first = token_stream_peek(tokens)
        if length(first) == 0 {
            return ret
        }
        if first[0] != token.op {
            return ret
        }
        if parse_is_not_in(first[1], ops[depth]) {
            return ret
        }
        token_stream_skip1(tokens)
        ret = [vm.ast.op, first[1], ret, paka_read_expr(tokens, depth + 1, state)]
    }
}

def paka_read_expr_base(tokens, state) {
    ret = paka_read_expr(tokens, 0, state)
    return ret
}

def paka_read_stmt(tokens, state) {
    first = token_stream_peek(tokens)
    if first[0] == token.keyword.while {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.while, expr, block]
    }
    if first[0] == token.keyword.def {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        block = paka_read_block(tokens, state)
        return [vm.ast.def, expr, block]
    }
    if first[0] == token.keyword.return {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        return [vm.ast.return, expr]
    }
    if first[0] == token.keyword.defer {
        token_stream_skip1(tokens)
        expr = paka_read_expr_base(tokens, state)
        return [vm.ast.defer, expr]
    }
    if first[0] == token.keyword.macro {
        token_stream_skip1(tokens)
        name = token_stream_read(tokens)
        first = token_stream_peek(tokens)
        block = paka_read_block(tokens, state)
        return [vm.ast.enum, [vm.ast.ident, name[1]], block]
    }
    if first[0] == token.keyword.exit {
        token_stream_skip1(tokens)
        return [vm.ast.exit]
    }
    ret = paka_read_expr_base(tokens, state)
    return ret
}

def paka_read_block_body(tokens, state) {
    ret = [vm.ast.do]
    while 1 {
        first = token_stream_peek(tokens)
        if length(first) == 0 {
            return ret
        }
        if first[0] == token.close.curly {
            return ret
        }
        stmt = paka_read_stmt(tokens, state)
        ret = ret ~ [stmt]
    }
}

def paka_read_block(tokens, state) {
    first = token_stream_peek(tokens)
    if first[0] == token.open.curly {
        token_stream_skip1(tokens)
        ret = paka_read_block_body(tokens, state)
        token_stream_skip1(tokens)
        return ret
    }
    return [vm.ast.do, paka_read_stmt(tokens, state)]
}

def paka_read_nargs(tokens, name, state) {
    got = token_stream_peek(tokens)
    if got[0] == token.open.paren {
        token_stream_skip1(tokens)
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error: need `)` after args to def")
                exit
            }
            if cur[0] == token.close.paren {
                token_stream_skip1(tokens)
                return n
            }
            paka_read_expr_base(tokens, state)
            n = n + 1
            paka_skip_comma(tokens)
        }
    } else {
        n = 0
        while 1 {
            cur = token_stream_peek(tokens)
            if length(cur) == 0 {
                puts("error: need `:` after def")
            }
            if cur[0] == token.op {
                if str.eq(cur[1], ":") {
                    token_stream_skip1(tokens)
                    return n
                }
            }
            paka_read_expr_base(tokens, state)
            n = n + 1
            paka_skip_comma(tokens)
        }
    }
}

def paka_build_defs(tokens, state) {
    ret = []
    while 1 {
        first = token_stream_read(tokens)
        if first[0] == token.keyword.def {
            name = token_stream_read(tokens)
            argc = paka_read_nargs(tokens, name[1], state)
            ret = ret ~ [name[1], argc]
        }
        if length(first) == 0 {
            return ret
        }
    }
}

def paka_parse(src) {
    ops = [["="], [":"], ["<", ">", "<=", ">=", "==", "!="], ["~", "+", "-"], ["%", "*", "/"], ["@"]]
    state = [ops, []]
    state = [ops, paka_build_defs(token_stream_new(src), state)]
    ret = paka_read_block_body(token_stream_new(src), state)
    return ret
}

## main

def main(argv) {
    outfile = "exec.bc"
    srcfile = ""
    i = 0
    while i < length(argv) {
        arg = argv[i]
        if arg[0] == '-' {
            if arg[1] == 'o' {
                i = i + 1
                outfile = argv[i]
            }
        } else {
            if length(srcfile) != 0 {
                puts("only one source can be provided")
                exit
            }
            srcfile = arg
        }
        i = i + 1
    }
    if length(srcfile) == 0 {
        puts("no sources provided")
        exit
    }
    src = read(srcfile)
    if length(src) == 0 {
        puts("cannot read file")
        exit
    }
    ast = paka_parse(src)
    bc = emit(ast, srcfile)
    dump(outfile, bc)
}

main(args)
exit
