
## --- vm.paka ---
## This is an implementation of MiniVM in Paka itself.
## Use the minivm compiler from the minivm repo for best speed (https://github.com/fastvm/minivm).
## This implementation uses meta-circular intepretation (https://en.wikipedia.org/wiki/Meta-circular_evaluator).

## opcodes each have a number
## currently all opcodes are implemented

macro opcode {
    let do_exit 0
    let do_reg 1
    let do_branch_bool 2
    let do_num 3
    let do_jump 4
    let do_func 5
    let do_add 6
    let do_sub 7
    let do_mul 8
    let do_div 9
    let do_mod 10
    let do_blte 11
    let do_call 12
    let do_ret 13
    let do_putchar 14
    let do_string 15
    let do_length 16
    let do_get 17
    let do_set 18
    let do_dump 19
    let do_read 20
    let do_write 21
    let do_array 22
    let do_cat 23
    let do_beq 24
    let do_blt 25
    let do_addi 26
    let do_subi 27
    let do_muli 28
    let do_divi 29
    let do_modi 30
    let do_geti 31
    let do_seti 32
    let do_bltei 33
    let do_beqi 34
    let do_blti 35
    let do_call0 36
    let do_call1 37
    let do_call2 38
    let do_call3 39
}

## dont worry about what these macros say
## this defines ops.read.num to read a number from the opcode stream
## this defines ops.read.reg to read a register's contents
macro ops.read {
    let num do let cur get ops index do let index add index 1 cur
    let reg get locals add head do let cur get ops index do let index add index 1 cur
}

## Paka <3 C

def put(str) {
    let i 0
    while lt i length str {
        putchar get str i
        let i add i 1
    }
}

def puts(str) {
    put str
    putchar 10
}

def putn_gte0(n) {
    if gte n 10 {
        let lowest mod n 10
        putn_gte0 div sub n lowest 10
        putchar add lowest 48
    } else {
        putchar add 48 mod n 10
    }
}

def putn(n) {
    if lt n 0 {
        put "-"
        putn_gte0 sub 0 n
    } else {
        putn_gte0 n
    }
}

## the vm loop
def vm.run(ops index locals head nexthead) {
    ## lopp until return or exit is hit
    while 1 {
        ## this is the opcode
        let op ops.read.num
        ## dont worry about these if-else chains, minivm compiles them to a branch table
        if eq op opcode.do_jump {
            let index ops.read.num
        } else if eq op opcode.do_reg {
            set locals add head ops.read.num ops.read.reg
        } else if eq op opcode.do_beqi {
            if eq ops.read.reg ops.read.num {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_addi {
           set locals add head ops.read.num add ops.read.reg ops.read.num
        } else if eq op opcode.do_call1 {
            let oreg ops.read.num
            let func ops.read.num
            set locals add nexthead 1 ops.read.reg
            let nregs get ops sub func 1
            let res vm.run ops func locals nexthead add nexthead nregs
            set locals add head oreg res
        } else if eq op opcode.do_add {
           set locals add head ops.read.num add ops.read.reg ops.read.reg
        } else if eq op opcode.do_sub {
           set locals add head ops.read.num sub ops.read.reg ops.read.reg
        } else if eq op opcode.do_num {
            set locals add head ops.read.num ops.read.num
        } else if eq op opcode.do_ret {
            return ops.read.reg
        } else if eq op opcode.do_blte {
            if lte ops.read.reg ops.read.reg {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_beq {
            if eq ops.read.reg ops.read.reg {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_blt {
            if lt ops.read.reg ops.read.reg {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_branch_bool {
            if neq ops.read.reg 0 {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_geti {
            set locals add head ops.read.num get ops.read.reg ops.read.num
        } else if eq op opcode.do_call2 {
            let oreg ops.read.num
            let func ops.read.num
            set locals add nexthead 1 ops.read.reg
            set locals add nexthead 2 ops.read.reg
            let nregs get ops sub func 1
            let res vm.run ops func locals nexthead add nexthead nregs
            set locals add head oreg res
        } else if eq op opcode.do_call3 {
            let oreg ops.read.num
            let func ops.read.num
            set locals add nexthead 1 ops.read.reg
            set locals add nexthead 2 ops.read.reg
            set locals add nexthead 2 ops.read.reg
            let nregs get ops sub func 1
            let res vm.run ops func locals nexthead add nexthead nregs
            set locals add head oreg res
        } else if eq op opcode.do_mul {
           set locals add head ops.read.num mul ops.read.reg ops.read.reg
        } else if eq op opcode.do_div {
           set locals add head ops.read.num div ops.read.reg ops.read.reg
        } else if eq op opcode.do_mod {
           set locals add head ops.read.num mod ops.read.reg ops.read.reg
        } else if eq op opcode.do_get {
            set locals add head ops.read.num get ops.read.reg ops.read.reg
        } else if eq op opcode.do_set {
            set ops.read.reg ops.read.reg ops.read.reg
        } else if eq op opcode.do_subi {
           set locals add head ops.read.num sub ops.read.reg ops.read.num
        } else if eq op opcode.do_muli {
           set locals add head ops.read.num mul ops.read.reg ops.read.num
        } else if eq op opcode.do_divi {
           set locals add head ops.read.num div ops.read.reg ops.read.num
        } else if eq op opcode.do_modi {
           set locals add head ops.read.num mod ops.read.reg ops.read.num
        } else if eq op opcode.do_seti {
            set ops.read.reg ops.read.num ops.read.reg
        } else if eq op opcode.do_bltei {
            if lte ops.read.reg ops.read.num {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_blti {
            if lt ops.read.reg ops.read.num {
                let index get ops add index 1
            } else {
                let index get ops index
            }
        } else if eq op opcode.do_call {
            let oreg ops.read.num
            let func ops.read.num
            let nargs ops.read.num
            let i 1
            while lte i nargs {
                set locals add nexthead i ops.read.reg
                let i add i 1
            } 
            let nregs get ops sub func 1
            let res vm.run ops func locals nexthead add nexthead nregs
            set locals add head oreg res 
        } else if eq op opcode.do_call0 {
            let oreg ops.read.num
            let func ops.read.num
            let nregs get ops sub func 1
            let res vm.run ops func locals nexthead add nexthead nregs
            set locals add head oreg res
        } else if eq op opcode.do_length {
            set locals add head ops.read.num length ops.read.reg
        } else if eq op opcode.do_array {
            let oreg ops.read.num
            let nargs ops.read.num
            let res []
            let i 1
            while lte i nargs {
                let res cat res [ops.read.reg]
                let i add i 1
            } 
            set locals add head oreg res
        } else if eq op opcode.do_string {
            let oreg ops.read.num
            let nargs ops.read.num
            let res []
            let i 1
            while lte i nargs {
                let res cat res [ops.read.num]
                let i add i 1
            } 
            set locals add head oreg res
        } else if eq op opcode.do_read {
            set locals add head ops.read.num read ops.read.reg
        } else if eq op opcode.do_dump {
            dump ops.read.reg ops.read.reg 
        } else if eq op opcode.do_write {
            write ops.read.reg ops.read.reg 
        } else if eq op opcode.do_cat {
           set locals add head ops.read.num cat ops.read.reg ops.read.reg
        } else if eq op opcode.do_putchar {
            putchar ops.read.reg 
        } else if eq op opcode.do_exit {
            exit
        } else if eq op opcode.do_func {
            let index ops.read.num
        } else {
            puts "bad opcode"
            exit
        }
    }
}

def main(args) {
    ## we need args
    if eq 0 length args {
        puts "need a file as argument"
        exit
    } 
    ## minivm sets length to zero if a file cannot be read
    let bytes read get args 0
    if eq 0 length bytes {
        puts "need file to exist and not be empty"
        exit
    }
    ## read bytecode from endian specifics
    let bc []
    let i 0
    while lt i length bytes {
        let v0 get bytes i let i add i 1
        let v1 get bytes i let i add i 1
        let v2 get bytes i let i add i 1
        let v3 get bytes i let i add i 1
        let bc cat bc [add v0 mul 256 add v1 mul 256 add v2 mul 256 v3]
    }
    ## locals 1 << 16 of them
    let locals [0]
    let i 0
    while lt i 16 {
        let locals cat locals locals
        let i add i 1
    }
    ## build args into register zero
    let arr []
    let i 1
    while lt i length args {
        let arr cat arr [get args i]
        let i add i 1
    }
    set locals 0 arr
    ## run bytecode from index zero
    ## with locals starting at r0 and ending at r256
    vm.run bc 0 locals 0 256
}

main args
return 0
